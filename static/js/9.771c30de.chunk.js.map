{"version":3,"sources":["../node_modules/@toruslabs/solana-embed/node_modules/readable-stream/errors-browser.js","../node_modules/@toruslabs/solana-embed/node_modules/readable-stream/lib/_stream_duplex.js","../node_modules/@toruslabs/solana-embed/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","../node_modules/@toruslabs/solana-embed/node_modules/readable-stream/lib/_stream_readable.js","../node_modules/@toruslabs/solana-embed/node_modules/readable-stream/lib/internal/streams/stream-browser.js","../node_modules/@toruslabs/solana-embed/node_modules/readable-stream/lib/internal/streams/destroy.js","../node_modules/@toruslabs/solana-embed/node_modules/readable-stream/lib/internal/streams/state.js","../node_modules/@toruslabs/solana-embed/node_modules/readable-stream/lib/_stream_writable.js","../node_modules/@toruslabs/solana-embed/node_modules/readable-stream/lib/_stream_transform.js","../../src/messages.ts","../../src/interfaces.ts","../../src/config.ts","../../src/loglevel.ts","../../src/utils.ts","../../src/baseProvider.ts","../../src/embedUtils.ts","../../src/PopupHandler.ts","../../src/communicationProvider.ts","../../src/inPageProvider.ts","../../src/siteMetadata.ts","../../src/embed.ts","../../src/basePostMessageStream.ts","../../src/safeEventEmitter.ts","../../src/serializableError.ts","../../src/jrpc.ts","../../src/jrpcEngine.ts","../../src/substream.ts","../../src/mux.ts","../node_modules/@toruslabs/solana-embed/node_modules/readable-stream/readable-browser.js","../node_modules/@toruslabs/solana-embed/node_modules/readable-stream/lib/internal/streams/buffer_list.js","../node_modules/@toruslabs/solana-embed/node_modules/readable-stream/lib/internal/streams/async_iterator.js","../node_modules/@toruslabs/solana-embed/node_modules/readable-stream/lib/internal/streams/from-browser.js","../node_modules/@toruslabs/solana-embed/node_modules/readable-stream/lib/_stream_passthrough.js","../node_modules/@toruslabs/solana-embed/node_modules/readable-stream/lib/internal/streams/pipeline.js","../../src/randomId.ts","../../src/url.ts","../../src/solanaWalletAdapter.ts"],"names":["codes","createErrorType","code","message","Base","Error","NodeError","_Base","subClass","superClass","arg1","arg2","arg3","call","this","getMessage","prototype","Object","create","constructor","__proto__","name","oneOf","expected","thing","Array","isArray","len","length","map","i","String","concat","slice","join","value","TypeError","actual","determiner","search","pos","msg","substr","replace","str","this_len","undefined","substring","endsWith","type","start","indexOf","includes","arg","module","exports","objectKeys","keys","obj","key","push","Duplex","Readable","require","Writable","v","method","options","allowHalfOpen","readable","writable","once","onend","_writableState","ended","process","nextTick","onEndNT","self","end","defineProperty","enumerable","get","highWaterMark","getBuffer","_readableState","destroyed","set","ERR_STREAM_PREMATURE_CLOSE","noop","eos","stream","opts","callback","called","_len","arguments","args","_key","apply","onlegacyfinish","onfinish","writableEnded","finished","readableEnded","endEmitted","onerror","err","onclose","onrequest","req","on","setHeader","abort","isRequest","error","removeListener","ReadableState","EventEmitter","EElistenerCount","emitter","listeners","Stream","Buffer","OurUint8Array","global","Uint8Array","debug","debugUtil","debuglog","StringDecoder","createReadableStreamAsyncIterator","from","BufferList","destroyImpl","getHighWaterMark","_require$codes","ERR_INVALID_ARG_TYPE","ERR_STREAM_PUSH_AFTER_EOF","ERR_METHOD_NOT_IMPLEMENTED","ERR_STREAM_UNSHIFT_AFTER_END_EVENT","errorOrDestroy","kProxyEvents","isDuplex","objectMode","readableObjectMode","buffer","pipes","pipesCount","flowing","reading","sync","needReadable","emittedReadable","readableListening","resumeScheduled","paused","emitClose","autoDestroy","defaultEncoding","awaitDrain","readingMore","decoder","encoding","read","_read","destroy","_destroy","readableAddChunk","chunk","addToFront","skipChunkCheck","er","state","emitReadable","emitReadable_","onEofChunk","isBuffer","chunkInvalid","getPrototypeOf","_uint8ArrayToBuffer","addChunk","write","maybeReadMore","emit","unshift","_undestroy","undestroy","cb","isPaused","setEncoding","enc","p","head","content","data","next","clear","MAX_HWM","howMuchToRead","n","computeNewHighWaterMark","flow","maybeReadMore_","updateReadableListening","listenerCount","resume","nReadingNextTick","resume_","fromList","ret","shift","first","consume","endReadable","endReadableNT","wState","xs","x","l","parseInt","nOrig","doRead","pipe","dest","pipeOpts","src","endFn","stdout","stderr","unpipe","onunpipe","unpipeInfo","hasUnpiped","ondrain","ondata","cleanedUp","needDrain","pipeOnDrain","pause","event","fn","prependListener","_events","dests","index","splice","ev","res","addListener","removeAllListeners","wrap","_this","bind","Symbol","asyncIterator","_fromList","iterable","emitErrorAndCloseNT","emitErrorNT","emitCloseNT","readableDestroyed","writableDestroyed","errorEmitted","ending","finalCalled","prefinished","rState","ERR_INVALID_OPT_VALUE","duplexKey","hwm","highWaterMarkFrom","isFinite","Math","floor","CorkedRequest","entry","finish","corkReq","pendingcb","corkedRequestsFree","onCorkedFinish","WritableState","internalUtil","deprecate","realHasInstance","ERR_MULTIPLE_CALLBACK","ERR_STREAM_CANNOT_PIPE","ERR_STREAM_DESTROYED","ERR_STREAM_NULL_VALUES","ERR_STREAM_WRITE_AFTER_END","ERR_UNKNOWN_ENCODING","nop","writableObjectMode","noDecode","decodeStrings","writing","corked","bufferProcessing","onwrite","writecb","writelen","onwriteStateUpdate","finishMaybe","onwriteError","needFinish","bufferedRequest","clearBuffer","afterWrite","lastBufferedRequest","bufferedRequestCount","_write","writev","_writev","final","_final","doWrite","onwriteDrain","holder","count","allBuffers","isBuf","callFinal","need","prefinish","current","out","_","hasInstance","Function","object","writeAfterEnd","validChunk","newChunk","decodeChunk","last","writeOrBuffer","cork","uncork","setDefaultEncoding","toLowerCase","endWritable","Transform","ERR_TRANSFORM_ALREADY_TRANSFORMING","ERR_TRANSFORM_WITH_LENGTH_0","afterTransform","ts","_transformState","transforming","writechunk","rs","needTransform","writeencoding","transform","_transform","flush","_flush","done","err2","disconnected","permanentlyDisconnected","unsupportedSync","invalidDuplexStream","invalidOptions","maxEventListeners","invalidRequestArgs","invalidRequestMethod","invalidRequestParams","invalidLoggerObject","invalidLoggerMethod","connected","chainId","TORUS_BUILD_ENV","BUTTON_POSITION","supportedVerifierList","api","translations","en","embed","continue","actionRequired","pendingAction","cookiesRequired","enableCookies","clickHere","de","ja","ko","zh","prodTorusUrl","localStorageKey","window","loglevel","getWindowId","getTorusUrl","torusUrl","logLevel","FEATURES_PROVIDER_CHANGE_WINDOW","height","width","FEATURES_DEFAULT_WALLET_WINDOW","FEATURES_DEFAULT_POPUP_WINDOW","FEATURES_CONFIRM_WINDOW","h","dualScreenLeft","dualScreenTop","document","left","top","w","jsonRpcStreamName","isDuplexStream","messages","mux","pump","jsonRpcConnection","createStreamMiddleware","rpcEngine","createIdRemapMiddleware","log","createLoggerMiddleware","origin","location","request","params","getRpcPromiseCallback","send","sendAsync","_handleStreamDisconnect","remoteLabel","warningMsg","logStreamDisconnectWarning","handleEvent","handlerArgs","handlerWrapper","handler","handle","resolve","htmlToElement","html","template","trimmedHtml","features","target","getPopupFeatures","_setupTimer","Number","setInterval","clearInterval","open","Promise","close","redirect","TorusCommunicationProvider","languageTranslations","configuration","userLanguage","userLanguages","config","getUserLanguage","payload","COMMUNICATION_NOTIFICATIONS","rid","isFull","url","currentLoginProvider","isLoggedIn","isIFrameFullScreen","isConnected","_initializeState","torusIframe","COMMUNICATION_JRPC_METHODS","_handleWindow","finalUrl","handledWindow","windowId","_displayIframe","style","hideTorusButton","showTorusButton","_rpcRequest","_payload","_handleConnect","_handleDisconnect","errorMessage","_handleCloseWindow","_createPopupBlockAlert","logoUrl","torusAlert","successAlert","btnContainer","bindOnLoad","attachOnLoad","documentReady","getLogoUrl","buttonPosition","hasEmittedConnection","torusWidgetVisibility","initialized","isPermanentlyDisconnected","TorusInPageProvider","PROVIDER_NOTIFICATIONS","PROVIDER_JRPC_METHODS","isUnlocked","accounts","isInternal","_handleAccountsChanged","isEthAccounts","finalAccounts","dequal","_handleChainChanged","_handleUnlockStateChanged","img","reject","getSiteName","siteName","metaTitle","icon","imgExists","_icon","Boolean","getSiteMetadata","getSiteIcon","version","PROVIDER_UNSAFE_METHODS","COMMUNICATION_UNSAFE_METHODS","isLocalStorageAvailable","storage","e","storageAvailable","torusIframeHtml","modalZIndex","init","buildEnv","enableLogging","useLocalStorage","apiKey","extraParams","setAPIKey","dappStorageKey","torusIframeUrl","hashParams","handleSetup","dappMetadata","network","login","loginWithPrivateKey","userInfo","privateKey","success","logout","cleanUp","clearInit","element","isElement","setProvider","showWallet","instanceId","finalPath","path","walletWindow","getUserInfo","userInfoResponse","initiateTopup","provider","topupResponse","getAccounts","response","sendTransaction","requireAllSignatures","signTransaction","transaction","messageOnly","parsed","JSON","signature","publicKey","signAllTransactions","encodedMessage","tx","responses","signatures","item","transactions","signMessage","getGaslessPublicKey","handleDappStorageKey","storedKey","generatedKey","_setupWeb3","providerStream","targetWindow","contentWindow","communicationStream","inPageProvider","communicationProvider","detectAccountRequestPrototypeModifier","m","originalMethod","loginProvider","proxiedInPageProvider","deleteProperty","proxiedCommunicationProvider","torusAlertContainer","ACK","targetOrigin","_break","_handShake","_onData","_postMessage","originConstraint","onMessage","Reflect","setTimeout","arr","copy","doError","events","safeApply","arrayClone","toString","stringify","stack","unwrapResult","idMap","processNotification","context","processResponse","middleware","originalId","newId","randomId","asMiddleware","JRPCEngine","handlerCallback","_handleBatch","reqs","_promiseHandle","_handle","id","jsonrpc","callerReq","serializeError","_processRequest","_runAllMiddleware","returnHandlers","isComplete","_runMiddleware","returnHandler","_runReturnHandlers","_checkForCompletion","IGNORE_SUBSTREAM","createStream","substream","parent","anyStreamEnd","_error","ignoreStream","PassThrough","pipeline","ownKeys","enumerableOnly","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","_defineProperty","configurable","_defineProperties","props","descriptor","inspect","custom","instance","Constructor","_classCallCheck","tail","protoProps","staticProps","s","alloc","offset","allocUnsafe","hasStrings","_getString","_getBuffer","c","nb","buf","source","forEach","getOwnPropertyDescriptors","defineProperties","_objectSpread","depth","customInspect","_Object$setPrototypeO","kLastResolve","kLastReject","kError","kEnded","kLastPromise","kHandlePromise","kStream","createIterResult","readAndResolve","iter","onReadable","AsyncIteratorPrototype","ReadableStreamAsyncIteratorPrototype","setPrototypeOf","promise","lastPromise","then","wrapForNext","_this2","_Object$create","iterator","ERR_MISSING_ARGS","destroyer","closed","to","popCallback","streams","pop","destroys","reduce","randombytes","WALLET_ADAPTERS","TORUS_SOLANA","ADAPTER_NAMESPACES","SOLANA","CHAIN_NAMESPACES","ADAPTER_CATEGORY","EXTERNAL","ADAPTER_STATUS","NOT_READY","solanaProvider","tickerName","rpcTarget","blockExplorerUrl","displayName","ticker","logo","getChainConfig","chainConfig","ADAPTER_EVENTS","connect","WalletInitializationError","adapter","torusInpageProvider","reconnected","rehydrated","WalletLoginError","disconnect","cleanup","setAdapterSettings"],"mappings":"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","file":"static/js/9.771c30de.chunk.js","sourcesContent":["'use strict';\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar codes = {};\n\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error;\n  }\n\n  function getMessage(arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message;\n    } else {\n      return message(arg1, arg2, arg3);\n    }\n  }\n\n  var NodeError =\n  /*#__PURE__*/\n  function (_Base) {\n    _inheritsLoose(NodeError, _Base);\n\n    function NodeError(arg1, arg2, arg3) {\n      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;\n    }\n\n    return NodeError;\n  }(Base);\n\n  NodeError.prototype.name = Base.name;\n  NodeError.prototype.code = code;\n  codes[code] = NodeError;\n} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\n\n\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    var len = expected.length;\n    expected = expected.map(function (i) {\n      return String(i);\n    });\n\n    if (len > 2) {\n      return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\n    } else if (len === 2) {\n      return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\n    } else {\n      return \"of \".concat(thing, \" \").concat(expected[0]);\n    }\n  } else {\n    return \"of \".concat(thing, \" \").concat(String(expected));\n  }\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\n\n\nfunction startsWith(str, search, pos) {\n  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\n\n\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n\n  return str.substring(this_len - search.length, this_len) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\n\n\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\n\ncreateErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n  return 'The value \"' + value + '\" is invalid for option \"' + name + '\"';\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  // determiner: 'must be' or 'must not be'\n  var determiner;\n\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n\n  var msg;\n\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  } else {\n    var type = includes(name, '.') ? 'property' : 'argument';\n    msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  }\n\n  msg += \". Received type \".concat(typeof actual);\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\ncreateErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n  return 'The ' + name + ' method is not implemented';\n});\ncreateErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\ncreateErrorType('ERR_STREAM_DESTROYED', function (name) {\n  return 'Cannot call ' + name + ' after a stream was destroyed';\n});\ncreateErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\ncreateErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\ncreateErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\ncreateErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\ncreateErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n  return 'Unknown encoding: ' + arg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\nmodule.exports.codes = codes;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n'use strict';\n/*<replacement>*/\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n\n  for (var key in obj) {\n    keys.push(key);\n  }\n\n  return keys;\n};\n/*</replacement>*/\n\n\nmodule.exports = Duplex;\n\nvar Readable = require('./_stream_readable');\n\nvar Writable = require('./_stream_writable');\n\nrequire('inherits')(Duplex, Readable);\n\n{\n  // Allow the keys array to be GC'ed.\n  var keys = objectKeys(Writable.prototype);\n\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n}); // the no-half-open enforcer\n\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return; // no more data can be written.\n  // But allow more writes to happen in this tick.\n\n  process.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});","// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n'use strict';\n\nvar ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    callback.apply(this, args);\n  };\n}\n\nfunction noop() {}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction eos(stream, opts, callback) {\n  if (typeof opts === 'function') return eos(stream, null, opts);\n  if (!opts) opts = {};\n  callback = once(callback || noop);\n  var readable = opts.readable || opts.readable !== false && stream.readable;\n  var writable = opts.writable || opts.writable !== false && stream.writable;\n\n  var onlegacyfinish = function onlegacyfinish() {\n    if (!stream.writable) onfinish();\n  };\n\n  var writableEnded = stream._writableState && stream._writableState.finished;\n\n  var onfinish = function onfinish() {\n    writable = false;\n    writableEnded = true;\n    if (!readable) callback.call(stream);\n  };\n\n  var readableEnded = stream._readableState && stream._readableState.endEmitted;\n\n  var onend = function onend() {\n    readable = false;\n    readableEnded = true;\n    if (!writable) callback.call(stream);\n  };\n\n  var onerror = function onerror(err) {\n    callback.call(stream, err);\n  };\n\n  var onclose = function onclose() {\n    var err;\n\n    if (readable && !readableEnded) {\n      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n\n    if (writable && !writableEnded) {\n      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n  };\n\n  var onrequest = function onrequest() {\n    stream.req.on('finish', onfinish);\n  };\n\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    stream.on('abort', onclose);\n    if (stream.req) onrequest();else stream.on('request', onrequest);\n  } else if (writable && !stream._writableState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (opts.error !== false) stream.on('error', onerror);\n  stream.on('close', onclose);\n  return function () {\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n}\n\nmodule.exports = eos;","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict';\n\nmodule.exports = Readable;\n/*<replacement>*/\n\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n/*<replacement>*/\n\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*<replacement>*/\n\n\nvar debugUtil = require('util');\n\nvar debug;\n\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\n\nvar BufferList = require('./internal/streams/buffer_list');\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\n\n\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\n\nrequire('inherits')(Readable, Stream);\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n\n  this.sync = true; // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\n\n  this.autoDestroy = !!options.autoDestroy; // has it been destroyed\n\n  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\n\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n}; // Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\n\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n}; // Unshift should *always* be something directly out of read()\n\n\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  } // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n\n\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n\n  return er;\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n}; // backwards compatibility.\n\n\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\n\n  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\n\n  var p = this._readableState.buffer.head;\n  var content = '';\n\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n\n  this._readableState.buffer.clear();\n\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n}; // Don't raise the hwm > 1GB\n\n\nvar MAX_HWM = 0x40000000;\n\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n\n  return n;\n} // This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n; // Don't have enough\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n\n  return state.length;\n} // you can override either this method, or the async _read(n) below.\n\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  } // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n  // if we need a readable event, then we need to do some reading.\n\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  } // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n    if (state.length === 0) state.needReadable = true; // call internal read method\n\n    this._read(state.highWaterMark);\n\n    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n\n  state.ended = true;\n\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n} // Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\n\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  } // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n\n\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n} // at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\n\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) // didn't get any data, stop spinning.\n      break;\n  }\n\n  state.readingMore = false;\n} // abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\n\n\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  } // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n\n  function cleanup() {\n    debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true; // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n\n      src.pause();\n    }\n  } // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  } // Make sure our error handler is attached before userland ones.\n\n\n  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n\n  dest.once('close', onclose);\n\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  } // tell the dest that it's being piped to\n\n\n  dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  }; // if we're not piping anywhere, then do nothing.\n\n  if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes; // got a match.\n\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  } // slow case. multiple pipe destinations.\n\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      });\n    }\n\n    return this;\n  } // try to find the right one.\n\n\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n}; // set up data events if they are asked for\n// Ensure readable listeners eventually get something\n\n\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n\n  return res;\n};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true; // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n} // pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\n\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n\n  if (!state.flowing) {\n    debug('resume'); // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n\n  state.paused = false;\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n\n  this._readableState.paused = true;\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n\n  while (state.flowing && stream.read() !== null) {\n    ;\n  }\n} // wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\n\n\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  }); // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  } // proxy certain important events.\n\n\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  } // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n\n\n  this._read = function (n) {\n    debug('wrapped _read', n);\n\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n\n    return createReadableStreamAsyncIterator(this);\n  };\n}\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n}); // exposed for testing purposes only.\n\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n}); // Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = require('./internal/streams/from');\n    }\n\n    return from(Readable, iterable, opts);\n  };\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n\n  return -1;\n}","module.exports = require('events').EventEmitter;\n","'use strict'; // undocumented cb() API, needed for core, not for public API\n\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n\n    return this;\n  } // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  } // if this is a duplex stream mark the writable part as destroyed as well\n\n\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else {\n        process.nextTick(emitCloseNT, _this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, _this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, _this);\n    }\n  });\n\n  return this;\n}\n\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\n\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy,\n  errorOrDestroy: errorOrDestroy\n};","'use strict';\n\nvar ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;\n\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\n\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n\n  if (hwm != null) {\n    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n      var name = isDuplex ? duplexKey : 'highWaterMark';\n      throw new ERR_INVALID_OPT_VALUE(name, hwm);\n    }\n\n    return Math.floor(hwm);\n  } // Default value\n\n\n  return state.objectMode ? 16 : 16 * 1024;\n}\n\nmodule.exports = {\n  getHighWaterMark: getHighWaterMark\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n'use strict';\n\nmodule.exports = Writable;\n/* <replacement> */\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n} // It seems a linked list but it is not\n// there will be only 2 of these for each stream\n\n\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\n\n\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n/*<replacement>*/\n\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\n\nrequire('inherits')(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called\n\n  this.finalCalled = false; // drain event flag.\n\n  this.needDrain = false; // at the start of calling end()\n\n  this.ending = false; // when end() has been called, and returned\n\n  this.ended = false; // when 'finish' is emitted\n\n  this.finished = false; // has it been destroyed\n\n  this.destroyed = false; // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n\n  this.length = 0; // a flag to see when we're in the middle of a write.\n\n  this.writing = false; // when true all writes will be buffered until .uncork() call\n\n  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n\n  this.sync = true; // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n\n  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n  this.writecb = null; // the amount that is being written when _write is called.\n\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n\n  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n\n  this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')\n\n  this.autoDestroy = !!options.autoDestroy; // count buffered requests\n\n  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})(); // Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\n\n\nvar realHasInstance;\n\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex); // legacy.\n\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n} // Otherwise people can pipe Writable streams, which is just wrong.\n\n\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb\n\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n} // Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\n\n\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n\n  return true;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n}); // if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\n\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er); // this can emit finish, and it will always happen\n    // after error\n\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er); // this can emit finish, but finish must\n    // always follow error\n\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n} // Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\n\n\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n} // if there's something in the buffer waiting, then process it\n\n\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  } // ignore unnecessary end() calls.\n\n\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n\n  if (need) {\n    prefinish(stream, state);\n\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  } // reuse the free corkReq.\n\n\n  state.corkedRequestsFree.next = corkReq;\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\n\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n'use strict';\n\nmodule.exports = Transform;\n\nvar _require$codes = require('../errors').codes,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\n\nvar Duplex = require('./_stream_duplex');\n\nrequire('inherits')(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  }; // start out asking for a readable event once data is transformed.\n\n  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  } // When the writable side finishes, then flush out anything remaining.\n\n\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n}; // This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\n\n\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n}; // Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\n\n\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}","import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { PublicKey } from '@solana/web3.js';\nimport { createLoggerMiddleware, COMMUNICATION_JRPC_METHODS, COMMUNICATION_NOTIFICATIONS, PROVIDER_JRPC_METHODS, PROVIDER_NOTIFICATIONS } from '@toruslabs/base-controllers';\nimport { setAPIKey } from '@toruslabs/http-helpers';\nimport { SafeEventEmitter, ObjectMultiplex, createStreamMiddleware, JRPCEngine, createIdRemapMiddleware, getRpcPromiseCallback, BasePostMessageStream } from '@toruslabs/openlogin-jrpc';\nimport { ethErrors, EthereumRpcError } from 'eth-rpc-errors';\nimport { duplex } from 'is-stream';\nimport pump from 'pump';\nimport loglevel from 'loglevel';\nimport dequal from 'fast-deep-equal';\n\nvar messages = {\n  errors: {\n    disconnected: () => \"Torus: Lost connection to Torus.\",\n    permanentlyDisconnected: () => \"Torus: Disconnected from iframe. Page reload required.\",\n    unsupportedSync: method => \"Torus: The Torus Ethereum provider does not support synchronous methods like \".concat(method, \" without a callback parameter.\"),\n    invalidDuplexStream: () => \"Must provide a Node.js-style duplex stream.\",\n    invalidOptions: maxEventListeners => \"Invalid options. Received: { maxEventListeners: \".concat(maxEventListeners, \"}\"),\n    invalidRequestArgs: () => \"Expected a single, non-array, object argument.\",\n    invalidRequestMethod: () => \"'args.method' must be a non-empty string.\",\n    invalidRequestParams: () => \"'args.params' must be an object or array if provided.\",\n    invalidLoggerObject: () => \"'args.logger' must be an object if provided.\",\n    invalidLoggerMethod: method => \"'args.logger' must include required method '\".concat(method, \"'.\")\n  },\n  info: {\n    connected: chainId => \"Torus: Connected to chain with ID \\\"\".concat(chainId, \"\\\".\")\n  },\n  warnings: {}\n};\n\nconst PAYMENT_PROVIDER = {\n  MOONPAY: \"moonpay\",\n  WYRE: \"wyre\",\n  RAMPNETWORK: \"rampnetwork\",\n  XANPOOL: \"xanpool\",\n  MERCURYO: \"mercuryo\",\n  TRANSAK: \"transak\"\n};\nconst TORUS_BUILD_ENV = {\n  PRODUCTION: \"production\",\n  DEVELOPMENT: \"development\",\n  TESTING: \"testing\"\n};\nconst BUTTON_POSITION = {\n  BOTTOM_LEFT: \"bottom-left\",\n  TOP_LEFT: \"top-left\",\n  BOTTOM_RIGHT: \"bottom-right\",\n  TOP_RIGHT: \"top-right\"\n};\nconst LOGIN_PROVIDER = {\n  GOOGLE: \"google\",\n  FACEBOOK: \"facebook\",\n  REDDIT: \"reddit\",\n  DISCORD: \"discord\",\n  TWITCH: \"twitch\",\n  APPLE: \"apple\",\n  LINE: \"line\",\n  GITHUB: \"github\",\n  KAKAO: \"kakao\",\n  LINKEDIN: \"linkedin\",\n  TWITTER: \"twitter\",\n  WEIBO: \"weibo\",\n  WECHAT: \"wechat\",\n  EMAIL_PASSWORDLESS: \"email_passwordless\"\n};\n\nconst translations = {\n  en: {\n    embed: {\n      continue: \"Continue\",\n      actionRequired: \"Authorization required\",\n      pendingAction: \"Click continue to proceed with your request in a popup\",\n      cookiesRequired: \"Cookies Required\",\n      enableCookies: \"Please enable cookies in your browser preferences to access Torus\",\n      clickHere: \"More Info\"\n    }\n  },\n  de: {\n    embed: {\n      continue: \"Fortsetzen\",\n      actionRequired: \"Autorisierung erforderlich\",\n      pendingAction: \"Klicken Sie in einem Popup auf Weiter, um mit Ihrer Anfrage fortzufahren\",\n      cookiesRequired: \"Cookies benötigt\",\n      enableCookies: \"Bitte aktivieren Sie Cookies in Ihren Browsereinstellungen, um auf Torus zuzugreifen\",\n      clickHere: \"Mehr Info\"\n    }\n  },\n  ja: {\n    embed: {\n      continue: \"継続する\",\n      actionRequired: \"認証が必要です\",\n      pendingAction: \"続行をクリックして、ポップアップでリクエストを続行します\",\n      cookiesRequired: \"必要なクッキー\",\n      enableCookies: \"Torusにアクセスするには、ブラウザの設定でCookieを有効にしてください。\",\n      clickHere: \"詳しくは\"\n    }\n  },\n  ko: {\n    embed: {\n      continue: \"계속하다\",\n      actionRequired: \"승인 필요\",\n      pendingAction: \"팝업에서 요청을 진행하려면 계속을 클릭하십시오.\",\n      cookiesRequired: \"쿠키 필요\",\n      enableCookies: \"브라우저 환경 설정에서 쿠키를 활성화하여 Torus에 액세스하십시오.\",\n      clickHere: \"더 많은 정보\"\n    }\n  },\n  zh: {\n    embed: {\n      continue: \"继续\",\n      actionRequired: \"需要授权\",\n      pendingAction: \"单击继续以在弹出窗口中继续您的请求\",\n      cookiesRequired: \"必填Cookie\",\n      enableCookies: \"请在您的浏览器首选项中启用cookie以访问Torus。\",\n      clickHere: \"更多信息\"\n    }\n  }\n};\nvar configuration = {\n  supportedVerifierList: [LOGIN_PROVIDER.GOOGLE, LOGIN_PROVIDER.REDDIT, LOGIN_PROVIDER.DISCORD],\n  api: \"https://api.tor.us\",\n  translations,\n  prodTorusUrl: \"\",\n  localStorageKey: \"torus-\".concat(window.location.hostname)\n};\n\nvar log = loglevel.getLogger(\"solana-embed\");\n\n/**\n * json-rpc-engine middleware that logs RPC errors and and validates req.method.\n *\n * @param log - The logging API to use.\n * @returns  json-rpc-engine middleware function\n */\n\nfunction createErrorMiddleware() {\n  return (req, res, next) => {\n    // json-rpc-engine will terminate the request when it notices this error\n    if (typeof req.method !== \"string\" || !req.method) {\n      res.error = ethErrors.rpc.invalidRequest({\n        message: \"The request 'method' must be a non-empty string.\",\n        data: req\n      });\n    }\n\n    next(done => {\n      const {\n        error\n      } = res;\n\n      if (!error) {\n        return done();\n      }\n\n      log.error(\"Torus - RPC Error: \".concat(error.message), error);\n      return done();\n    });\n  };\n}\n/**\n * Logs a stream disconnection error. Emits an 'error' if given an\n * EventEmitter that has listeners for the 'error' event.\n *\n * @param log - The logging API to use.\n * @param remoteLabel - The label of the disconnected stream.\n * @param error - The associated error to log.\n * @param emitter - The logging API to use.\n */\n\nfunction logStreamDisconnectWarning(remoteLabel, error, emitter) {\n  let warningMsg = \"Torus: Lost connection to \\\"\".concat(remoteLabel, \"\\\".\");\n\n  if (error !== null && error !== void 0 && error.stack) {\n    warningMsg += \"\\n\".concat(error.stack);\n  }\n\n  log.warn(warningMsg);\n\n  if (emitter && emitter.listenerCount(\"error\") > 0) {\n    emitter.emit(\"error\", warningMsg);\n  }\n}\nconst getWindowId = () => Math.random().toString(36).slice(2);\nconst getTorusUrl = async buildEnv => {\n  let torusUrl;\n  let logLevel; // const versionUsed = version;\n  // log.info(\"solana embed version used: \", versionUsed);\n\n  switch (buildEnv) {\n    case \"testing\":\n      torusUrl = \"https://solana-testing.tor.us\";\n      logLevel = \"debug\";\n      break;\n\n    case \"development\":\n      torusUrl = \"http://localhost:8080\";\n      logLevel = \"debug\";\n      break;\n\n    default:\n      torusUrl = \"https://solana.tor.us\";\n      logLevel = \"error\";\n      break;\n  }\n\n  return {\n    torusUrl,\n    logLevel\n  };\n};\nconst getUserLanguage = () => {\n  let userLanguage = window.navigator.language || \"en-US\";\n  const userLanguages = userLanguage.split(\"-\");\n  userLanguage = Object.prototype.hasOwnProperty.call(configuration.translations, userLanguages[0]) ? userLanguages[0] : \"en\";\n  return userLanguage;\n};\nconst FEATURES_PROVIDER_CHANGE_WINDOW = {\n  height: 660,\n  width: 375\n};\nconst FEATURES_DEFAULT_WALLET_WINDOW = {\n  height: 740,\n  width: 1315\n};\nconst FEATURES_DEFAULT_POPUP_WINDOW = {\n  height: 700,\n  width: 1200\n};\nconst FEATURES_CONFIRM_WINDOW = {\n  height: 600,\n  width: 400\n};\nfunction storageAvailable(type) {\n  let storage;\n\n  try {\n    storage = window[type];\n    const x = \"__storage_test__\";\n    storage.setItem(x, x);\n    storage.removeItem(x);\n    return true;\n  } catch (e) {\n    return e && ( // everything except Firefox\n    e.code === 22 || // Firefox\n    e.code === 1014 || // test name field too, because code might not be present\n    // everything except Firefox\n    e.name === \"QuotaExceededError\" || // Firefox\n    e.name === \"NS_ERROR_DOM_QUOTA_REACHED\") && // acknowledge QuotaExceededError only if there's something already stored\n    storage && storage.length !== 0;\n  }\n}\n/**\n * popup handler utils\n */\n\nfunction getPopupFeatures(_ref) {\n  let {\n    width: w,\n    height: h\n  } = _ref;\n  // Fixes dual-screen position                             Most browsers      Firefox\n  const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;\n  const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;\n  const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;\n  const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;\n  const systemZoom = 1; // No reliable estimate\n\n  const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);\n  const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);\n  const features = \"titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=\".concat(h / systemZoom, \",width=\").concat(w / systemZoom, \",top=\").concat(top, \",left=\").concat(left);\n  return features;\n}\n\nclass BaseProvider extends SafeEventEmitter {\n  /**\n   * Indicating that this provider is a Torus provider.\n   */\n  constructor(connectionStream, _ref) {\n    let {\n      maxEventListeners = 100,\n      jsonRpcStreamName = \"provider\"\n    } = _ref;\n    super();\n\n    _defineProperty(this, \"isTorus\", void 0);\n\n    _defineProperty(this, \"_rpcEngine\", void 0);\n\n    _defineProperty(this, \"jsonRpcConnectionEvents\", void 0);\n\n    _defineProperty(this, \"_state\", void 0);\n\n    if (!duplex(connectionStream)) {\n      throw new Error(messages.errors.invalidDuplexStream());\n    }\n\n    this.isTorus = true;\n    this.setMaxListeners(maxEventListeners);\n    this._handleConnect = this._handleConnect.bind(this);\n    this._handleDisconnect = this._handleDisconnect.bind(this);\n    this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this);\n    this._rpcRequest = this._rpcRequest.bind(this);\n    this._initializeState = this._initializeState.bind(this);\n    this.request = this.request.bind(this);\n    this.sendAsync = this.sendAsync.bind(this); // this.enable = this.enable.bind(this);\n    // setup connectionStream multiplexing\n\n    const mux = new ObjectMultiplex();\n    pump(connectionStream, mux, connectionStream, this._handleStreamDisconnect.bind(this, \"Torus\")); // ignore phishing warning message (handled elsewhere)\n\n    mux.ignoreStream(\"phishing\"); // setup own event listeners\n    // connect to async provider\n\n    const jsonRpcConnection = createStreamMiddleware();\n    pump(jsonRpcConnection.stream, mux.createStream(jsonRpcStreamName), jsonRpcConnection.stream, this._handleStreamDisconnect.bind(this, \"Torus RpcProvider\")); // handle RPC requests via dapp-side rpc engine\n\n    const rpcEngine = new JRPCEngine();\n    rpcEngine.push(createIdRemapMiddleware());\n    rpcEngine.push(createErrorMiddleware());\n    rpcEngine.push(createLoggerMiddleware({\n      origin: location.origin\n    }));\n    rpcEngine.push(jsonRpcConnection.middleware);\n    this._rpcEngine = rpcEngine;\n    this.jsonRpcConnectionEvents = jsonRpcConnection.events;\n  }\n  /**\n   * Submits an RPC request for the given method, with the given params.\n   * Resolves with the result of the method call, or rejects on error.\n   */\n\n\n  async request(args) {\n    if (!args || typeof args !== \"object\" || Array.isArray(args)) {\n      throw ethErrors.rpc.invalidRequest({\n        message: messages.errors.invalidRequestArgs(),\n        data: args\n      });\n    }\n\n    const {\n      method,\n      params\n    } = args;\n\n    if (typeof method !== \"string\" || method.length === 0) {\n      throw ethErrors.rpc.invalidRequest({\n        message: messages.errors.invalidRequestMethod(),\n        data: args\n      });\n    }\n\n    if (params !== undefined && !Array.isArray(params) && (typeof params !== \"object\" || params === null)) {\n      throw ethErrors.rpc.invalidRequest({\n        message: messages.errors.invalidRequestParams(),\n        data: args\n      });\n    }\n\n    return new Promise((resolve, reject) => {\n      this._rpcRequest({\n        method,\n        params\n      }, getRpcPromiseCallback(resolve, reject));\n    });\n  }\n  /**\n   * Submits an RPC request per the given JSON-RPC request object.\n   */\n\n\n  send(payload, callback) {\n    this._rpcRequest(payload, callback);\n  }\n  /**\n   * Submits an RPC request per the given JSON-RPC request object.\n   */\n\n\n  sendAsync(payload) {\n    return new Promise((resolve, reject) => {\n      this._rpcRequest(payload, getRpcPromiseCallback(resolve, reject));\n    });\n  }\n  /**\n   * Called when connection is lost to critical streams.\n   *\n   * emits TorusInpageProvider#disconnect\n   */\n\n\n  _handleStreamDisconnect(streamName, error) {\n    logStreamDisconnectWarning(streamName, error, this);\n\n    this._handleDisconnect(false, error ? error.message : undefined);\n  }\n\n}\n\nconst handleEvent = function (handle, eventName, handler) {\n  for (var _len = arguments.length, handlerArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    handlerArgs[_key - 3] = arguments[_key];\n  }\n\n  const handlerWrapper = () => {\n    handler(...handlerArgs);\n    handle.removeEventListener(eventName, handlerWrapper);\n  };\n\n  handle.addEventListener(eventName, handlerWrapper);\n};\nasync function documentReady() {\n  return new Promise(resolve => {\n    if (document.readyState !== \"loading\") {\n      resolve();\n    } else {\n      handleEvent(document, \"DOMContentLoaded\", resolve);\n    }\n  });\n}\nconst htmlToElement = html => {\n  const template = window.document.createElement(\"template\");\n  const trimmedHtml = html.trim(); // Never return a text node of whitespace as the result\n\n  template.innerHTML = trimmedHtml;\n  return template.content.firstChild;\n};\n\nclass PopupHandler extends SafeEventEmitter {\n  constructor(_ref) {\n    let {\n      url,\n      target,\n      features\n    } = _ref;\n    super();\n\n    _defineProperty(this, \"url\", void 0);\n\n    _defineProperty(this, \"target\", void 0);\n\n    _defineProperty(this, \"features\", void 0);\n\n    _defineProperty(this, \"window\", void 0);\n\n    _defineProperty(this, \"windowTimer\", void 0);\n\n    _defineProperty(this, \"iClosedWindow\", void 0);\n\n    this.url = url;\n    this.target = target || \"_blank\";\n    this.features = features || getPopupFeatures(FEATURES_DEFAULT_POPUP_WINDOW);\n    this.window = undefined;\n    this.windowTimer = undefined;\n    this.iClosedWindow = false;\n\n    this._setupTimer();\n  }\n\n  _setupTimer() {\n    this.windowTimer = Number(setInterval(() => {\n      if (this.window && this.window.closed) {\n        clearInterval(this.windowTimer);\n\n        if (!this.iClosedWindow) {\n          this.emit(\"close\");\n        }\n\n        this.iClosedWindow = false;\n        this.window = undefined;\n      }\n\n      if (this.window === undefined) clearInterval(this.windowTimer);\n    }, 500));\n  }\n\n  open() {\n    var _this$window;\n\n    this.window = window.open(this.url.href, this.target, this.features);\n    if ((_this$window = this.window) !== null && _this$window !== void 0 && _this$window.focus) this.window.focus();\n    return Promise.resolve();\n  }\n\n  close() {\n    this.iClosedWindow = true;\n    if (this.window) this.window.close();\n  }\n\n  redirect(locationReplaceOnRedirect) {\n    if (locationReplaceOnRedirect) {\n      window.location.replace(this.url.href);\n    } else {\n      window.location.href = this.url.href;\n    }\n  }\n\n}\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nclass TorusCommunicationProvider extends BaseProvider {\n  constructor(connectionStream, _ref) {\n    let {\n      maxEventListeners = 100,\n      jsonRpcStreamName = \"provider\"\n    } = _ref;\n    super(connectionStream, {\n      maxEventListeners,\n      jsonRpcStreamName\n    }); // private state\n\n    _defineProperty(this, \"embedTranslations\", void 0);\n\n    _defineProperty(this, \"torusUrl\", void 0);\n\n    _defineProperty(this, \"dappStorageKey\", void 0);\n\n    _defineProperty(this, \"windowRefs\", void 0);\n\n    _defineProperty(this, \"tryWindowHandle\", void 0);\n\n    _defineProperty(this, \"torusAlertContainer\", void 0);\n\n    _defineProperty(this, \"torusIframe\", void 0);\n\n    this._state = _objectSpread$2({}, TorusCommunicationProvider._defaultState); // public state\n\n    this.torusUrl = \"\";\n    this.dappStorageKey = \"\";\n    const languageTranslations = configuration.translations[getUserLanguage()];\n    this.embedTranslations = languageTranslations.embed;\n    this.windowRefs = {}; // setup own event listeners\n    // EIP-1193 connect\n\n    this.on(\"connect\", () => {\n      this._state.isConnected = true;\n    });\n\n    const notificationHandler = payload => {\n      const {\n        method,\n        params\n      } = payload;\n\n      if (method === COMMUNICATION_NOTIFICATIONS.IFRAME_STATUS) {\n        const {\n          isFullScreen,\n          rid\n        } = params;\n\n        this._displayIframe({\n          isFull: isFullScreen,\n          rid: rid\n        });\n      } else if (method === COMMUNICATION_NOTIFICATIONS.CREATE_WINDOW) {\n        const {\n          windowId,\n          url\n        } = params;\n\n        this._createPopupBlockAlert(windowId, url);\n      } else if (method === COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW) {\n        this._handleCloseWindow(params);\n      } else if (method === COMMUNICATION_NOTIFICATIONS.USER_LOGGED_IN) {\n        const {\n          currentLoginProvider\n        } = params;\n        this._state.isLoggedIn = true;\n        this._state.currentLoginProvider = currentLoginProvider;\n      } else if (method === COMMUNICATION_NOTIFICATIONS.USER_LOGGED_OUT) {\n        this._state.isLoggedIn = false;\n        this._state.currentLoginProvider = null;\n\n        this._displayIframe();\n      }\n    };\n\n    this.jsonRpcConnectionEvents.on(\"notification\", notificationHandler);\n  }\n\n  get isLoggedIn() {\n    return this._state.isLoggedIn;\n  }\n\n  get isIFrameFullScreen() {\n    return this._state.isIFrameFullScreen;\n  }\n  /**\n   * Returns whether the inPage provider is connected to Torus.\n   */\n\n\n  isConnected() {\n    return this._state.isConnected;\n  }\n\n  async _initializeState(params) {\n    try {\n      const {\n        torusUrl,\n        dappStorageKey,\n        torusAlertContainer,\n        torusIframe\n      } = params;\n      this.torusUrl = torusUrl;\n      this.dappStorageKey = dappStorageKey;\n      this.torusAlertContainer = torusAlertContainer;\n      this.torusIframe = torusIframe;\n      this.torusIframe.addEventListener(\"load\", () => {\n        // only do this if iframe is not full screen\n        if (!this._state.isIFrameFullScreen) this._displayIframe();\n      });\n      const {\n        currentLoginProvider,\n        isLoggedIn\n      } = await this.request({\n        method: COMMUNICATION_JRPC_METHODS.GET_PROVIDER_STATE,\n        params: []\n      }); // indicate that we've connected, for EIP-1193 compliance\n\n      this._handleConnect(currentLoginProvider, isLoggedIn);\n    } catch (error) {\n      log.error(\"Torus: Failed to get initial state. Please report this bug.\", error);\n    } finally {\n      log.info(\"initialized communication state\");\n      this._state.initialized = true;\n      this.emit(\"_initialized\");\n    }\n  }\n\n  _handleWindow(windowId) {\n    let {\n      url,\n      target,\n      features\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const finalUrl = new URL(url || \"\".concat(this.torusUrl, \"/redirect?windowId=\").concat(windowId));\n\n    if (this.dappStorageKey) {\n      // If multiple instances, it returns the first one\n      if (finalUrl.hash) finalUrl.hash += \"&dappStorageKey=\".concat(this.dappStorageKey);else finalUrl.hash = \"#dappStorageKey=\".concat(this.dappStorageKey);\n    }\n\n    const handledWindow = new PopupHandler({\n      url: finalUrl,\n      target,\n      features\n    });\n    handledWindow.open();\n\n    if (!handledWindow.window) {\n      this._createPopupBlockAlert(windowId, finalUrl.href);\n\n      return;\n    } // Add to collection only if window is opened\n\n\n    this.windowRefs[windowId] = handledWindow; // We tell the iframe that the window has been successfully opened\n\n    this.request({\n      method: COMMUNICATION_JRPC_METHODS.OPENED_WINDOW,\n      params: {\n        windowId\n      }\n    });\n    handledWindow.once(\"close\", () => {\n      // user closed the window\n      delete this.windowRefs[windowId];\n      this.request({\n        method: COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW,\n        params: {\n          windowId\n        }\n      });\n    });\n  }\n\n  _displayIframe() {\n    let {\n      isFull = false,\n      rid = \"\"\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const style = {}; // set phase\n\n    if (!isFull) {\n      style.display = this._state.torusWidgetVisibility ? \"block\" : \"none\";\n      style.height = \"70px\";\n      style.width = \"70px\";\n\n      switch (this._state.buttonPosition) {\n        case BUTTON_POSITION.TOP_LEFT:\n          style.top = \"0px\";\n          style.left = \"0px\";\n          style.right = \"auto\";\n          style.bottom = \"auto\";\n          break;\n\n        case BUTTON_POSITION.TOP_RIGHT:\n          style.top = \"0px\";\n          style.right = \"0px\";\n          style.left = \"auto\";\n          style.bottom = \"auto\";\n          break;\n\n        case BUTTON_POSITION.BOTTOM_RIGHT:\n          style.bottom = \"0px\";\n          style.right = \"0px\";\n          style.top = \"auto\";\n          style.left = \"auto\";\n          break;\n\n        case BUTTON_POSITION.BOTTOM_LEFT:\n        default:\n          style.bottom = \"0px\";\n          style.left = \"0px\";\n          style.top = \"auto\";\n          style.right = \"auto\";\n          break;\n      }\n    } else {\n      style.display = \"block\";\n      style.width = \"100%\";\n      style.height = \"100%\";\n      style.top = \"0px\";\n      style.right = \"0px\";\n      style.left = \"0px\";\n      style.bottom = \"0px\";\n    }\n\n    Object.assign(this.torusIframe.style, style);\n    this._state.isIFrameFullScreen = isFull;\n    this.request({\n      method: COMMUNICATION_JRPC_METHODS.IFRAME_STATUS,\n      params: {\n        isIFrameFullScreen: isFull,\n        rid\n      }\n    });\n  }\n\n  hideTorusButton() {\n    this._state.torusWidgetVisibility = false;\n\n    this._displayIframe();\n  }\n\n  showTorusButton() {\n    this._state.torusWidgetVisibility = true;\n\n    this._displayIframe();\n  }\n  /**\n   * Internal RPC method. Forwards requests to background via the RPC engine.\n   * Also remap ids inbound and outbound\n   */\n\n\n  _rpcRequest(payload, callback) {\n    const cb = callback;\n    const _payload = payload;\n\n    if (!Array.isArray(_payload)) {\n      if (!_payload.jsonrpc) {\n        _payload.jsonrpc = \"2.0\";\n      }\n    }\n\n    this.tryWindowHandle(_payload, cb);\n  }\n  /**\n   * When the provider becomes connected, updates internal state and emits\n   * required events. Idempotent.\n   *\n   * @param currentLoginProvider - The login Provider\n   * emits TorusInpageProvider#connect\n   */\n\n\n  _handleConnect(currentLoginProvider, isLoggedIn) {\n    if (!this._state.isConnected) {\n      this._state.isConnected = true;\n      this.emit(\"connect\", {\n        currentLoginProvider,\n        isLoggedIn\n      });\n      log.debug(messages.info.connected(currentLoginProvider));\n    }\n  }\n  /**\n   * When the provider becomes disconnected, updates internal state and emits\n   * required events. Idempotent with respect to the isRecoverable parameter.\n   *\n   * Error codes per the CloseEvent status codes as required by EIP-1193:\n   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n   *\n   * @param isRecoverable - Whether the disconnection is recoverable.\n   * @param errorMessage - A custom error message.\n   * emits TorusInpageProvider#disconnect\n   */\n\n\n  _handleDisconnect(isRecoverable, errorMessage) {\n    if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !isRecoverable) {\n      this._state.isConnected = false;\n      let error;\n\n      if (isRecoverable) {\n        error = new EthereumRpcError(1013, // Try again later\n        errorMessage || messages.errors.disconnected());\n        log.debug(error);\n      } else {\n        error = new EthereumRpcError(1011, // Internal error\n        errorMessage || messages.errors.permanentlyDisconnected());\n        log.error(error);\n        this._state.currentLoginProvider = null;\n        this._state.isLoggedIn = false;\n        this._state.torusWidgetVisibility = false;\n        this._state.isIFrameFullScreen = false;\n        this._state.isPermanentlyDisconnected = true;\n      }\n\n      this.emit(\"disconnect\", error);\n    }\n  } // Called if the iframe wants to close the window cause it is done processing the request\n\n\n  _handleCloseWindow(params) {\n    const {\n      windowId\n    } = params;\n\n    if (this.windowRefs[windowId]) {\n      this.windowRefs[windowId].close();\n      delete this.windowRefs[windowId];\n    }\n  }\n\n  async _createPopupBlockAlert(windowId, url) {\n    const logoUrl = this.getLogoUrl();\n    const torusAlert = htmlToElement('<div id=\"torusAlert\" class=\"torus-alert--v2\">' + \"<div id=\\\"torusAlert__logo\\\"><img src=\\\"\".concat(logoUrl, \"\\\" /></div>\") + \"<div>\" + \"<h1 id=\\\"torusAlert__title\\\">\".concat(this.embedTranslations.actionRequired, \"</h1>\") + \"<p id=\\\"torusAlert__desc\\\">\".concat(this.embedTranslations.pendingAction, \"</p>\") + \"</div>\" + \"</div>\");\n    const successAlert = htmlToElement(\"<div><a id=\\\"torusAlert__btn\\\">\".concat(this.embedTranslations.continue, \"</a></div>\"));\n    const btnContainer = htmlToElement('<div id=\"torusAlert__btn-container\"></div>');\n    btnContainer.appendChild(successAlert);\n    torusAlert.appendChild(btnContainer);\n\n    const bindOnLoad = () => {\n      successAlert.addEventListener(\"click\", () => {\n        this._handleWindow(windowId, {\n          url,\n          target: \"_blank\",\n          features: getPopupFeatures(FEATURES_CONFIRM_WINDOW)\n        });\n\n        torusAlert.remove();\n        if (this.torusAlertContainer.children.length === 0) this.torusAlertContainer.style.display = \"none\";\n      });\n    };\n\n    const attachOnLoad = () => {\n      this.torusAlertContainer.appendChild(torusAlert);\n    };\n\n    await documentReady();\n    attachOnLoad();\n    bindOnLoad();\n    this.torusAlertContainer.style.display = \"block\";\n  }\n\n  getLogoUrl() {\n    const logoUrl = \"\".concat(this.torusUrl, \"/images/torus_icon-blue.svg\");\n    return logoUrl;\n  }\n\n}\n\n_defineProperty(TorusCommunicationProvider, \"_defaultState\", {\n  buttonPosition: \"bottom-left\",\n  currentLoginProvider: null,\n  isIFrameFullScreen: false,\n  hasEmittedConnection: false,\n  torusWidgetVisibility: false,\n  initialized: false,\n  isLoggedIn: false,\n  isPermanentlyDisconnected: false,\n  isConnected: false\n});\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nclass TorusInPageProvider extends BaseProvider {\n  /**\n   * The chain ID of the currently connected Solana chain.\n   * See [chainId.network]{@link https://chainid.network} for more information.\n   */\n\n  /**\n   * The user's currently selected Solana address.\n   * If null, Torus is either locked or the user has not permitted any\n   * addresses to be viewed.\n   */\n  constructor(connectionStream, _ref) {\n    let {\n      maxEventListeners = 100,\n      jsonRpcStreamName = \"provider\"\n    } = _ref;\n    super(connectionStream, {\n      maxEventListeners,\n      jsonRpcStreamName\n    }); // private state\n\n    _defineProperty(this, \"chainId\", void 0);\n\n    _defineProperty(this, \"selectedAddress\", void 0);\n\n    _defineProperty(this, \"tryWindowHandle\", void 0);\n\n    this._state = _objectSpread$1({}, TorusInPageProvider._defaultState); // public state\n\n    this.selectedAddress = null;\n    this.chainId = null;\n    this._handleAccountsChanged = this._handleAccountsChanged.bind(this);\n    this._handleChainChanged = this._handleChainChanged.bind(this);\n    this._handleUnlockStateChanged = this._handleUnlockStateChanged.bind(this); // setup own event listeners\n    // EIP-1193 connect\n\n    this.on(\"connect\", () => {\n      this._state.isConnected = true;\n    });\n\n    const jsonRpcNotificationHandler = payload => {\n      const {\n        method,\n        params\n      } = payload;\n\n      if (method === PROVIDER_NOTIFICATIONS.ACCOUNTS_CHANGED) {\n        this._handleAccountsChanged(params);\n      } else if (method === PROVIDER_NOTIFICATIONS.UNLOCK_STATE_CHANGED) {\n        this._handleUnlockStateChanged(params);\n      } else if (method === PROVIDER_NOTIFICATIONS.CHAIN_CHANGED) {\n        this._handleChainChanged(params);\n      }\n    }; // json rpc notification listener\n\n\n    this.jsonRpcConnectionEvents.on(\"notification\", jsonRpcNotificationHandler);\n  }\n  /**\n   * Returns whether the inpage provider is connected to Torus.\n   */\n\n\n  isConnected() {\n    return this._state.isConnected;\n  } // Private Methods\n  //= ===================\n\n  /**\n   * Constructor helper.\n   * Populates initial state by calling 'wallet_getProviderState' and emits\n   * necessary events.\n   */\n\n\n  async _initializeState() {\n    try {\n      const {\n        accounts,\n        chainId,\n        isUnlocked\n      } = await this.request({\n        method: PROVIDER_JRPC_METHODS.GET_PROVIDER_STATE,\n        params: []\n      }); // indicate that we've connected, for EIP-1193 compliance\n\n      this.emit(\"connect\", {\n        chainId\n      });\n\n      this._handleChainChanged({\n        chainId\n      });\n\n      this._handleUnlockStateChanged({\n        accounts,\n        isUnlocked\n      });\n\n      this._handleAccountsChanged(accounts);\n    } catch (error) {\n      log.error(\"Torus: Failed to get initial state. Please report this bug.\", error);\n    } finally {\n      log.info(\"initialized provider state\");\n      this._state.initialized = true;\n      this.emit(\"_initialized\");\n    }\n  }\n  /**\n   * Internal RPC method. Forwards requests to background via the RPC engine.\n   * Also remap ids inbound and outbound\n   */\n\n\n  _rpcRequest(payload, callback) {\n    let isInternal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let cb = callback;\n    const _payload = payload;\n\n    if (!Array.isArray(_payload)) {\n      if (!_payload.jsonrpc) {\n        _payload.jsonrpc = \"2.0\";\n      }\n\n      if (_payload.method === \"solana_accounts\" || _payload.method === \"solana_requestAccounts\") {\n        // handle accounts changing\n        cb = (err, res) => {\n          this._handleAccountsChanged(res.result || [], _payload.method === \"solana_accounts\", isInternal);\n\n          callback(err, res);\n        };\n      } else if (_payload.method === \"wallet_getProviderState\") {\n        this._rpcEngine.handle(payload, cb);\n\n        return;\n      }\n    }\n\n    this.tryWindowHandle(_payload, cb);\n  }\n  /**\n   * When the provider becomes connected, updates internal state and emits\n   * required events. Idempotent.\n   *\n   * @param chainId - The ID of the newly connected chain.\n   * emits TorusInpageProvider#connect\n   */\n\n\n  _handleConnect(chainId) {\n    if (!this._state.isConnected) {\n      this._state.isConnected = true;\n      this.emit(\"connect\", {\n        chainId\n      });\n      log.debug(messages.info.connected(chainId));\n    }\n  }\n  /**\n   * When the provider becomes disconnected, updates internal state and emits\n   * required events. Idempotent with respect to the isRecoverable parameter.\n   *\n   * Error codes per the CloseEvent status codes as required by EIP-1193:\n   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n   *\n   * @param isRecoverable - Whether the disconnection is recoverable.\n   * @param errorMessage - A custom error message.\n   * emits TorusInpageProvider#disconnect\n   */\n\n\n  _handleDisconnect(isRecoverable, errorMessage) {\n    if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !isRecoverable) {\n      this._state.isConnected = false;\n      let error;\n\n      if (isRecoverable) {\n        error = new EthereumRpcError(1013, // Try again later\n        errorMessage || messages.errors.disconnected());\n        log.debug(error);\n      } else {\n        error = new EthereumRpcError(1011, // Internal error\n        errorMessage || messages.errors.permanentlyDisconnected());\n        log.error(error);\n        this.chainId = null;\n        this._state.accounts = null;\n        this.selectedAddress = null;\n        this._state.isUnlocked = false;\n        this._state.isPermanentlyDisconnected = true;\n      }\n\n      this.emit(\"disconnect\", error);\n    }\n  }\n  /**\n   * Called when accounts may have changed.\n   */\n\n\n  _handleAccountsChanged(accounts) {\n    let isEthAccounts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let isInternal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    // defensive programming\n    let finalAccounts = accounts;\n\n    if (!Array.isArray(finalAccounts)) {\n      log.error(\"Torus: Received non-array accounts parameter. Please report this bug.\", finalAccounts);\n      finalAccounts = [];\n    }\n\n    for (const account of accounts) {\n      if (typeof account !== \"string\") {\n        log.error(\"Torus: Received non-string account. Please report this bug.\", accounts);\n        finalAccounts = [];\n        break;\n      }\n    } // emit accountsChanged if anything about the accounts array has changed\n\n\n    if (!dequal(this._state.accounts, finalAccounts)) {\n      // we should always have the correct accounts even before solana_accounts\n      // returns, except in cases where isInternal is true\n      if (isEthAccounts && Array.isArray(this._state.accounts) && this._state.accounts.length > 0 && !isInternal) {\n        log.error('Torus: \"solana_accounts\" unexpectedly updated accounts. Please report this bug.', finalAccounts);\n      }\n\n      this._state.accounts = finalAccounts;\n      this.emit(\"accountsChanged\", finalAccounts);\n    } // handle selectedAddress\n\n\n    if (this.selectedAddress !== finalAccounts[0]) {\n      this.selectedAddress = finalAccounts[0] || null;\n    }\n  }\n  /**\n   * Upon receipt of a new chainId and networkVersion, emits corresponding\n   * events and sets relevant public state.\n   * Does nothing if neither the chainId nor the networkVersion are different\n   * from existing values.\n   *\n   * emits TorusInpageProvider#chainChanged\n   * @param networkInfo - An object with network info.\n   */\n\n\n  _handleChainChanged() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!chainId) {\n      log.error(\"Torus: Received invalid network parameters. Please report this bug.\", {\n        chainId\n      });\n      return;\n    }\n\n    if (chainId === \"loading\") {\n      this._handleDisconnect(true);\n    } else {\n      this._handleConnect(chainId);\n\n      if (chainId !== this.chainId) {\n        this.chainId = chainId;\n\n        if (this._state.initialized) {\n          this.emit(\"chainChanged\", this.chainId);\n        }\n      }\n    }\n  }\n  /**\n   * Upon receipt of a new isUnlocked state, sets relevant public state.\n   * Calls the accounts changed handler with the received accounts, or an empty\n   * array.\n   *\n   * Does nothing if the received value is equal to the existing value.\n   * There are no lock/unlock events.\n   *\n   * @param opts - Options bag.\n   */\n\n\n  _handleUnlockStateChanged() {\n    let {\n      accounts,\n      isUnlocked\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (typeof isUnlocked !== \"boolean\") {\n      log.error(\"Torus: Received invalid isUnlocked parameter. Please report this bug.\", {\n        isUnlocked\n      });\n      return;\n    }\n\n    if (isUnlocked !== this._state.isUnlocked) {\n      this._state.isUnlocked = isUnlocked;\n\n      this._handleAccountsChanged(accounts || []);\n    }\n  }\n\n}\n\n_defineProperty(TorusInPageProvider, \"_defaultState\", {\n  accounts: null,\n  isConnected: false,\n  isUnlocked: false,\n  initialized: false,\n  isPermanentlyDisconnected: false,\n  hasEmittedConnection: false\n});\n\n/**\n * Returns whether the given image URL exists\n */\nfunction imgExists(url) {\n  return new Promise((resolve, reject) => {\n    try {\n      const img = document.createElement(\"img\");\n\n      img.onload = () => resolve(true);\n\n      img.onerror = () => resolve(false);\n\n      img.src = url;\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n/**\n * Extracts a name for the site from the DOM\n */\n\n\nconst getSiteName = window => {\n  const {\n    document\n  } = window;\n  const siteName = document.querySelector('head > meta[property=\"og:site_name\"]');\n\n  if (siteName) {\n    return siteName.content;\n  }\n\n  const metaTitle = document.querySelector('head > meta[name=\"title\"]');\n\n  if (metaTitle) {\n    return metaTitle.content;\n  }\n\n  if (document.title && document.title.length > 0) {\n    return document.title;\n  }\n\n  return window.location.hostname;\n};\n/**\n * Extracts an icon for the site from the DOM\n */\n\n\nasync function getSiteIcon(window) {\n  try {\n    const {\n      document\n    } = window; // Use the site's favicon if it exists\n\n    let icon = document.querySelector('head > link[rel=\"shortcut icon\"]');\n\n    if (icon && (await imgExists(icon.href))) {\n      return icon.href;\n    } // Search through available icons in no particular order\n\n\n    icon = Array.from(document.querySelectorAll('head > link[rel=\"icon\"]')).find(_icon => Boolean(_icon.href));\n\n    if (icon && (await imgExists(icon.href))) {\n      return icon.href;\n    }\n\n    return \"\";\n  } catch (error) {\n    return \"\";\n  }\n}\n/**\n * Gets site metadata and returns it\n *\n */\n\n\nconst getSiteMetadata = async () => ({\n  name: getSiteName(window),\n  icon: await getSiteIcon(window)\n});\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nconst {\n  version\n} = require(\"../package.json\");\n\nconst PROVIDER_UNSAFE_METHODS = [\"send_transaction\", \"sign_transaction\", \"sign_all_transactions\", \"sign_message\", \"connect\"];\nconst COMMUNICATION_UNSAFE_METHODS = [COMMUNICATION_JRPC_METHODS.SET_PROVIDER];\nconst isLocalStorageAvailable = storageAvailable(\"localStorage\"); // preload for iframe doesn't work https://bugs.chromium.org/p/chromium/issues/detail?id=593267\n\n(async function preLoadIframe() {\n  try {\n    if (typeof document === \"undefined\") return;\n    const torusIframeHtml = document.createElement(\"link\");\n    const {\n      torusUrl\n    } = await getTorusUrl(\"production\");\n    torusIframeHtml.href = \"\".concat(torusUrl, \"/frame\");\n    torusIframeHtml.crossOrigin = \"anonymous\";\n    torusIframeHtml.type = \"text/html\";\n    torusIframeHtml.rel = \"prefetch\";\n\n    if (torusIframeHtml.relList && torusIframeHtml.relList.supports) {\n      if (torusIframeHtml.relList.supports(\"prefetch\")) {\n        document.head.appendChild(torusIframeHtml);\n      }\n    }\n  } catch (error) {\n    log.warn(error);\n  }\n})();\n\nclass Torus {\n  constructor() {\n    let {\n      modalZIndex = 99999\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _defineProperty(this, \"isInitialized\", void 0);\n\n    _defineProperty(this, \"torusAlert\", void 0);\n\n    _defineProperty(this, \"modalZIndex\", void 0);\n\n    _defineProperty(this, \"alertZIndex\", void 0);\n\n    _defineProperty(this, \"requestedLoginProvider\", void 0);\n\n    _defineProperty(this, \"provider\", void 0);\n\n    _defineProperty(this, \"communicationProvider\", void 0);\n\n    _defineProperty(this, \"dappStorageKey\", void 0);\n\n    _defineProperty(this, \"torusAlertContainer\", void 0);\n\n    _defineProperty(this, \"torusUrl\", void 0);\n\n    _defineProperty(this, \"torusIframe\", void 0);\n\n    _defineProperty(this, \"styleLink\", void 0);\n\n    this.torusUrl = \"\";\n    this.isInitialized = false; // init done\n\n    this.requestedLoginProvider = null;\n    this.modalZIndex = modalZIndex;\n    this.alertZIndex = modalZIndex + 1000;\n    this.dappStorageKey = \"\";\n  }\n\n  get isLoggedIn() {\n    if (!this.communicationProvider) return false;\n    return this.communicationProvider.isLoggedIn;\n  }\n\n  async init() {\n    let {\n      buildEnv = TORUS_BUILD_ENV.PRODUCTION,\n      enableLogging = false,\n      network,\n      showTorusButton = false,\n      useLocalStorage = false,\n      buttonPosition = BUTTON_POSITION.BOTTOM_LEFT,\n      apiKey = \"torus-default\",\n      extraParams = {}\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (this.isInitialized) throw new Error(\"Already initialized\");\n    setAPIKey(apiKey);\n    const {\n      torusUrl,\n      logLevel\n    } = await getTorusUrl(buildEnv);\n    log.enableAll();\n    log.info(torusUrl, \"url loaded\");\n    log.info(\"Solana Embed Version :\".concat(version));\n    this.torusUrl = torusUrl;\n    log.setDefaultLevel(logLevel);\n    if (enableLogging) log.enableAll();else log.disableAll();\n    const dappStorageKey = this.handleDappStorageKey(useLocalStorage);\n    const torusIframeUrl = new URL(torusUrl);\n    if (torusIframeUrl.pathname.endsWith(\"/\")) torusIframeUrl.pathname += \"frame\";else torusIframeUrl.pathname += \"/frame\";\n    const hashParams = new URLSearchParams();\n    if (dappStorageKey) hashParams.append(\"dappStorageKey\", dappStorageKey);\n    hashParams.append(\"origin\", window.location.origin);\n    torusIframeUrl.hash = hashParams.toString(); // Iframe code\n\n    this.torusIframe = htmlToElement(\"<iframe\\n        id=\\\"torusIframe\\\"\\n        class=\\\"torusIframe\\\"\\n        src=\\\"\".concat(torusIframeUrl.href, \"\\\"\\n        style=\\\"display: none; position: fixed; top: 0; right: 0; width: 100%;\\n        height: 100%; border: none; border-radius: 0; z-index: \").concat(this.modalZIndex.toString(), \"\\\"\\n      ></iframe>\"));\n    this.torusAlertContainer = htmlToElement(\"<div id=\\\"torusAlertContainer\\\" style=\\\"display:none; z-index: \".concat(this.alertZIndex.toString(), \"\\\"></div>\"));\n    this.styleLink = htmlToElement(\"<link href=\\\"\".concat(torusUrl, \"/css/widget.css\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\">\"));\n\n    const handleSetup = async () => {\n      return new Promise((resolve, reject) => {\n        try {\n          window.document.head.appendChild(this.styleLink);\n          window.document.body.appendChild(this.torusIframe);\n          window.document.body.appendChild(this.torusAlertContainer);\n          this.torusIframe.addEventListener(\"load\", async () => {\n            const dappMetadata = await getSiteMetadata(); // send init params here\n\n            this.torusIframe.contentWindow.postMessage({\n              buttonPosition,\n              apiKey,\n              network,\n              dappMetadata,\n              extraParams\n            }, torusIframeUrl.origin);\n            await this._setupWeb3({\n              torusUrl\n            });\n            if (showTorusButton) this.showTorusButton();else this.hideTorusButton();\n            this.isInitialized = true;\n            window.torus = this;\n            resolve();\n          });\n        } catch (error) {\n          reject(error);\n        }\n      });\n    };\n\n    await documentReady();\n    await handleSetup();\n  }\n\n  async login() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!this.isInitialized) throw new Error(\"Call init() first\");\n\n    try {\n      this.requestedLoginProvider = params.loginProvider || null;\n\n      if (!this.requestedLoginProvider) {\n        this.communicationProvider._displayIframe({\n          isFull: true\n        });\n      } // If user is already logged in, we assume they have given access to the website\n\n\n      const res = await new Promise((resolve, reject) => {\n        // We use this method because we want to update inPage provider state with account info\n        this.provider._rpcRequest({\n          method: \"solana_requestAccounts\",\n          params: [this.requestedLoginProvider, params.login_hint]\n        }, getRpcPromiseCallback(resolve, reject));\n      });\n\n      if (Array.isArray(res) && res.length > 0) {\n        return res;\n      } // This would never happen, but just in case\n\n\n      throw new Error(\"Login failed\");\n    } catch (error) {\n      log.error(\"login failed\", error);\n      throw error;\n    } finally {\n      if (this.communicationProvider.isIFrameFullScreen) this.communicationProvider._displayIframe();\n    }\n  }\n\n  async loginWithPrivateKey(loginParams) {\n    if (!this.isInitialized) throw new Error(\"Call init() first\");\n    const {\n      privateKey,\n      userInfo\n    } = loginParams;\n    const {\n      success\n    } = await this.communicationProvider.request({\n      method: \"login_with_private_key\",\n      params: {\n        privateKey,\n        userInfo\n      }\n    });\n    if (!success) throw new Error(\"Login Failed\");\n  }\n\n  async logout() {\n    if (!this.communicationProvider.isLoggedIn) throw new Error(\"Not logged in\");\n    await this.communicationProvider.request({\n      method: COMMUNICATION_JRPC_METHODS.LOGOUT,\n      params: []\n    });\n    this.requestedLoginProvider = null;\n  }\n\n  async cleanUp() {\n    if (this.communicationProvider.isLoggedIn) {\n      await this.logout();\n    }\n\n    this.clearInit();\n  }\n\n  clearInit() {\n    function isElement(element) {\n      return element instanceof Element || element instanceof Document;\n    }\n\n    if (isElement(this.styleLink) && window.document.body.contains(this.styleLink)) {\n      this.styleLink.remove();\n      this.styleLink = undefined;\n    }\n\n    if (isElement(this.torusIframe) && window.document.body.contains(this.torusIframe)) {\n      this.torusIframe.remove();\n      this.torusIframe = undefined;\n    }\n\n    if (isElement(this.torusAlertContainer) && window.document.body.contains(this.torusAlertContainer)) {\n      this.torusAlert = undefined;\n      this.torusAlertContainer.remove();\n      this.torusAlertContainer = undefined;\n    }\n\n    this.isInitialized = false;\n  }\n\n  hideTorusButton() {\n    this.communicationProvider.hideTorusButton();\n  }\n\n  showTorusButton() {\n    this.communicationProvider.showTorusButton();\n  }\n\n  async setProvider(params) {\n    await this.communicationProvider.request({\n      method: COMMUNICATION_JRPC_METHODS.SET_PROVIDER,\n      params: _objectSpread({}, params)\n    });\n  }\n\n  async showWallet(path) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const instanceId = await this.communicationProvider.request({\n      method: COMMUNICATION_JRPC_METHODS.WALLET_INSTANCE_ID,\n      params: []\n    });\n    const finalPath = path ? \"/\".concat(path) : \"\";\n    const finalUrl = new URL(\"\".concat(this.torusUrl, \"/wallet\").concat(finalPath)); // Using URL constructor to prevent js injection and allow parameter validation.!\n\n    finalUrl.searchParams.append(\"instanceId\", instanceId);\n    Object.keys(params).forEach(x => {\n      finalUrl.searchParams.append(x, params[x]);\n    });\n\n    if (this.dappStorageKey) {\n      finalUrl.hash = \"#dappStorageKey=\".concat(this.dappStorageKey);\n    } // No need to track this window state. Hence, no _handleWindow call.\n\n\n    const walletWindow = new PopupHandler({\n      url: finalUrl,\n      features: getPopupFeatures(FEATURES_DEFAULT_WALLET_WINDOW)\n    });\n    walletWindow.open();\n  }\n\n  async getUserInfo() {\n    const userInfoResponse = await this.communicationProvider.request({\n      method: COMMUNICATION_JRPC_METHODS.USER_INFO,\n      params: []\n    });\n    return userInfoResponse;\n  }\n\n  async initiateTopup(provider, params) {\n    if (!this.isInitialized) throw new Error(\"Torus is not initialized\");\n    const windowId = getWindowId();\n\n    this.communicationProvider._handleWindow(windowId);\n\n    const topupResponse = await this.communicationProvider.request({\n      method: COMMUNICATION_JRPC_METHODS.TOPUP,\n      params: {\n        provider,\n        params,\n        windowId\n      }\n    });\n    return topupResponse;\n  } // Solana specific API\n\n\n  async getAccounts() {\n    const response = await this.provider.request({\n      method: \"getAccounts\",\n      params: []\n    });\n    return response;\n  }\n\n  async sendTransaction(transaction) {\n    const response = await this.provider.request({\n      method: \"send_transaction\",\n      params: {\n        message: transaction.serialize({\n          requireAllSignatures: false\n        }).toString(\"hex\")\n      }\n    });\n    return response;\n  }\n\n  async signTransaction(transaction) {\n    const response = await this.provider.request({\n      method: \"sign_transaction\",\n      params: {\n        message: transaction.serializeMessage().toString(\"hex\"),\n        messageOnly: true\n      }\n    }); // reconstruct signature pair\n\n    const parsed = JSON.parse(response);\n    const signature = {\n      publicKey: new PublicKey(parsed.publicKey),\n      signature: Buffer.from(parsed.signature, \"hex\")\n    };\n    transaction.addSignature(signature.publicKey, signature.signature);\n    return transaction;\n  }\n\n  async signAllTransactions(transactions) {\n    const encodedMessage = transactions.map(tx => {\n      return tx.serializeMessage().toString(\"hex\");\n    });\n    const responses = await this.provider.request({\n      method: \"sign_all_transactions\",\n      params: {\n        message: encodedMessage,\n        messageOnly: true\n      }\n    }); // reconstruct signature pairs\n\n    const signatures = responses.map(item => {\n      const parsed = JSON.parse(item);\n      return {\n        publicKey: new PublicKey(parsed.publicKey),\n        signature: Buffer.from(parsed.signature, \"hex\")\n      };\n    });\n    transactions.forEach((tx, idx) => {\n      tx.addSignature(signatures[idx].publicKey, signatures[idx].signature);\n      return tx;\n    });\n    return transactions;\n  }\n\n  async signMessage(data) {\n    const response = await this.provider.request({\n      method: \"sign_message\",\n      params: {\n        data\n      }\n    });\n    return response;\n  }\n\n  async getGaslessPublicKey() {\n    const response = await this.provider.request({\n      method: \"get_gasless_public_key\",\n      params: []\n    });\n    return response;\n  } // async connect(): Promise<boolean> {\n  //   const response = (await this.provider.request({\n  //     method: \"connect\",\n  //     params: {},\n  //   })) as boolean;\n  //   return response;\n  // }\n\n\n  handleDappStorageKey(useLocalStorage) {\n    let dappStorageKey = \"\";\n\n    if (isLocalStorageAvailable && useLocalStorage) {\n      const storedKey = window.localStorage.getItem(configuration.localStorageKey);\n      if (storedKey) dappStorageKey = storedKey;else {\n        const generatedKey = \"torus-app-\".concat(getWindowId());\n        window.localStorage.setItem(configuration.localStorageKey, generatedKey);\n        dappStorageKey = generatedKey;\n      }\n    }\n\n    this.dappStorageKey = dappStorageKey;\n    return dappStorageKey;\n  }\n\n  async _setupWeb3(providerParams) {\n    log.info(\"setupWeb3 running\"); // setup background connection\n\n    const providerStream = new BasePostMessageStream({\n      name: \"embed_torus\",\n      target: \"iframe_torus\",\n      targetWindow: this.torusIframe.contentWindow\n    }); // We create another LocalMessageDuplexStream for communication between dapp <> iframe\n\n    const communicationStream = new BasePostMessageStream({\n      name: \"embed_communication\",\n      target: \"iframe_communication\",\n      targetWindow: this.torusIframe.contentWindow\n    }); // compose the inPage provider\n\n    const inPageProvider = new TorusInPageProvider(providerStream, {});\n    const communicationProvider = new TorusCommunicationProvider(communicationStream, {});\n\n    inPageProvider.tryWindowHandle = (payload, cb) => {\n      const _payload = payload;\n\n      if (!Array.isArray(_payload) && PROVIDER_UNSAFE_METHODS.includes(_payload.method)) {\n        if (!this.communicationProvider.isLoggedIn) throw new Error(\"User Not Logged In\");\n        const windowId = getWindowId();\n\n        communicationProvider._handleWindow(windowId, {\n          target: \"_blank\",\n          features: getPopupFeatures(FEATURES_CONFIRM_WINDOW)\n        }); // for inPageProvider methods sending windowId in request instead of params\n        // as params might be positional.\n\n\n        _payload.windowId = windowId;\n      }\n\n      inPageProvider._rpcEngine.handle(_payload, cb);\n    };\n\n    communicationProvider.tryWindowHandle = (payload, cb) => {\n      const _payload = payload;\n\n      if (!Array.isArray(_payload) && COMMUNICATION_UNSAFE_METHODS.includes(_payload.method)) {\n        const windowId = getWindowId();\n\n        communicationProvider._handleWindow(windowId, {\n          target: \"_blank\",\n          features: getPopupFeatures(FEATURES_PROVIDER_CHANGE_WINDOW) // todo: are these features generic for all\n\n        }); // for communication methods sending window id in jrpc req params\n\n\n        _payload.params.windowId = windowId;\n      }\n\n      communicationProvider._rpcEngine.handle(_payload, cb);\n    }; // detect solana_requestAccounts and pipe to enable for now\n\n\n    const detectAccountRequestPrototypeModifier = m => {\n      const originalMethod = inPageProvider[m]; // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n      const self = this;\n\n      inPageProvider[m] = function providerFunc(request, cb) {\n        const {\n          method,\n          params = []\n        } = request;\n\n        if (method === \"solana_requestAccounts\") {\n          if (!cb) return self.login({\n            loginProvider: params[0]\n          });\n          self.login({\n            loginProvider: params[0]\n          }) // eslint-disable-next-line promise/no-callback-in-promise\n          .then(res => cb(null, res)) // eslint-disable-next-line promise/no-callback-in-promise\n          .catch(err => cb(err));\n        }\n\n        return originalMethod.apply(this, [request, cb]);\n      };\n    }; // Detects call to solana_requestAccounts in request & sendAsync and passes to login\n\n\n    detectAccountRequestPrototypeModifier(\"request\");\n    detectAccountRequestPrototypeModifier(\"sendAsync\");\n    detectAccountRequestPrototypeModifier(\"send\");\n    const proxiedInPageProvider = new Proxy(inPageProvider, {\n      // straight up lie that we deleted the property so that it doesn't\n      // throw an error in strict mode\n      deleteProperty: () => true\n    });\n    const proxiedCommunicationProvider = new Proxy(communicationProvider, {\n      // straight up lie that we deleted the property so that it doesn't\n      // throw an error in strict mode\n      deleteProperty: () => true\n    });\n    this.provider = proxiedInPageProvider;\n    this.communicationProvider = proxiedCommunicationProvider;\n    await Promise.all([inPageProvider._initializeState(), communicationProvider._initializeState(_objectSpread(_objectSpread({}, providerParams), {}, {\n      dappStorageKey: this.dappStorageKey,\n      torusAlertContainer: this.torusAlertContainer,\n      torusIframe: this.torusIframe\n    }))]);\n    log.debug(\"Torus - injected provider\");\n  }\n\n}\n\nexport { BUTTON_POSITION, LOGIN_PROVIDER, PAYMENT_PROVIDER, TORUS_BUILD_ENV, TorusInPageProvider, Torus as default };\n//# sourceMappingURL=solanaEmbed.esm.js.map\n",null,null,null,null,null,null,null,null,null,null,null,"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { Duplex } from 'readable-stream';\nimport { randomId } from '@toruslabs/openlogin-utils';\nimport { EventEmitter } from 'events';\nimport stringify from 'fast-safe-stringify';\nimport { serializeError } from 'eth-rpc-errors';\nimport eos from 'end-of-stream';\nimport once from 'once';\nimport pump from 'pump';\n\nfunction noop() {\n  return undefined;\n}\n\nconst SYN = \"SYN\";\nconst ACK = \"ACK\";\nconst BRK = \"BRK\";\nclass BasePostMessageStream extends Duplex {\n  constructor(_ref) {\n    let {\n      name,\n      target,\n      targetWindow = window,\n      targetOrigin = \"*\"\n    } = _ref;\n    super({\n      objectMode: true\n    });\n\n    _defineProperty(this, \"_init\", void 0);\n\n    _defineProperty(this, \"_haveSyn\", void 0);\n\n    _defineProperty(this, \"_name\", void 0);\n\n    _defineProperty(this, \"_target\", void 0);\n\n    _defineProperty(this, \"_targetWindow\", void 0);\n\n    _defineProperty(this, \"_targetOrigin\", void 0);\n\n    _defineProperty(this, \"_onMessage\", void 0);\n\n    _defineProperty(this, \"_synIntervalId\", void 0);\n\n    if (!name || !target) {\n      throw new Error(\"Invalid input.\");\n    }\n\n    this._init = false;\n    this._haveSyn = false;\n    this._name = name;\n    this._target = target; // target origin\n\n    this._targetWindow = targetWindow;\n    this._targetOrigin = targetOrigin;\n    this._onMessage = this.onMessage.bind(this);\n    this._synIntervalId = null;\n    window.addEventListener(\"message\", this._onMessage, false);\n\n    this._handShake();\n  }\n\n  _break() {\n    this.cork();\n\n    this._write(BRK, null, noop);\n\n    this._haveSyn = false;\n    this._init = false;\n  }\n\n  _handShake() {\n    this._write(SYN, null, noop);\n\n    this.cork();\n  }\n\n  _onData(data) {\n    if (!this._init) {\n      // listen for handshake\n      if (data === SYN) {\n        this._haveSyn = true;\n\n        this._write(ACK, null, noop);\n      } else if (data === ACK) {\n        this._init = true;\n\n        if (!this._haveSyn) {\n          this._write(ACK, null, noop);\n        }\n\n        this.uncork();\n      }\n    } else if (data === BRK) {\n      this._break();\n    } else {\n      // forward message\n      try {\n        this.push(data);\n      } catch (err) {\n        this.emit(\"error\", err);\n      }\n    }\n  }\n\n  _postMessage(data) {\n    const originConstraint = this._targetOrigin;\n\n    this._targetWindow.postMessage({\n      target: this._target,\n      data\n    }, originConstraint);\n  }\n\n  onMessage(event) {\n    const message = event.data; // validate message\n\n    if (this._targetOrigin !== \"*\" && event.origin !== this._targetOrigin || event.source !== this._targetWindow || typeof message !== \"object\" || message.target !== this._name || !message.data) {\n      return;\n    }\n\n    this._onData(message.data);\n  }\n\n  _read() {\n    return undefined;\n  }\n\n  _write(data, _, cb) {\n    this._postMessage(data);\n\n    cb();\n  }\n\n  _destroy() {\n    window.removeEventListener(\"message\", this._onMessage, false);\n  }\n\n}\n\nfunction safeApply(handler, context, args) {\n  try {\n    Reflect.apply(handler, context, args);\n  } catch (err) {\n    // Throw error after timeout so as not to interrupt the stack\n    setTimeout(() => {\n      throw err;\n    });\n  }\n}\n\nfunction arrayClone(arr) {\n  const n = arr.length;\n  const copy = new Array(n);\n\n  for (let i = 0; i < n; i += 1) {\n    copy[i] = arr[i];\n  }\n\n  return copy;\n}\n\nclass SafeEventEmitter extends EventEmitter {\n  emit(type) {\n    let doError = type === \"error\";\n    const events = this._events;\n\n    if (events !== undefined) {\n      doError = doError && events.error === undefined;\n    } else if (!doError) {\n      return false;\n    } // If there is no 'error' event listener then throw.\n\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    if (doError) {\n      let er;\n\n      if (args.length > 0) {\n        [er] = args;\n      }\n\n      if (er instanceof Error) {\n        // Note: The comments on the `throw` lines are intentional, they show\n        // up in Node's output if this results in an unhandled exception.\n        throw er; // Unhandled 'error' event\n      } // At least give some kind of context to the user\n\n\n      const err = new Error(\"Unhandled error.\".concat(er ? \" (\".concat(er.message, \")\") : \"\"));\n      err.context = er;\n      throw err; // Unhandled 'error' event\n    }\n\n    const handler = events[type];\n\n    if (handler === undefined) {\n      return false;\n    }\n\n    if (typeof handler === \"function\") {\n      safeApply(handler, this, args);\n    } else {\n      const len = handler.length;\n      const listeners = arrayClone(handler);\n\n      for (let i = 0; i < len; i += 1) {\n        safeApply(listeners[i], this, args);\n      }\n    }\n\n    return true;\n  }\n\n}\n\nclass SerializableError extends Error {\n  constructor(_ref) {\n    let {\n      code,\n      message,\n      data\n    } = _ref;\n\n    if (!Number.isInteger(code)) {\n      throw new Error(\"code must be an integer\");\n    }\n\n    if (!message || typeof message !== \"string\") {\n      throw new Error(\"message must be string\");\n    }\n\n    super(message);\n\n    _defineProperty(this, \"code\", void 0);\n\n    _defineProperty(this, \"data\", void 0);\n\n    this.code = code;\n\n    if (data !== undefined) {\n      this.data = data;\n    }\n  }\n\n  toString() {\n    return stringify({\n      code: this.code,\n      message: this.message,\n      data: this.data,\n      stack: this.stack\n    });\n  }\n\n}\n\nconst getRpcPromiseCallback = function (resolve, reject) {\n  let unwrapResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  return (error, response) => {\n    if (error || response.error) {\n      reject(error || response.error);\n    } else if (!unwrapResult || Array.isArray(response)) {\n      resolve(response);\n    } else {\n      resolve(response.result);\n    }\n  };\n};\nfunction createErrorMiddleware(log) {\n  return (req, res, next, end) => {\n    try {\n      // json-rpc-engine will terminate the request when it notices this error\n      if (typeof req.method !== \"string\" || !req.method) {\n        res.error = new SerializableError({\n          code: -32603,\n          message: \"invalid method\"\n        });\n        end();\n        return;\n      }\n\n      next(done => {\n        const {\n          error\n        } = res;\n\n        if (!error) {\n          return done();\n        }\n\n        log.error(\"OpenLogin - RPC Error: \".concat(error.message), error);\n        return done();\n      });\n    } catch (error) {\n      log.error(\"OpenLogin - RPC Error thrown: \".concat(error.message), error);\n      res.error = new SerializableError({\n        code: -32603,\n        message: error.message\n      });\n      end();\n    }\n  };\n}\nfunction createStreamMiddleware() {\n  const idMap = {};\n\n  function readNoop() {\n    return false;\n  }\n\n  const events = new SafeEventEmitter();\n\n  function processResponse(res) {\n    const context = idMap[res.id];\n\n    if (!context) {\n      throw new Error(\"StreamMiddleware - Unknown response id \\\"\".concat(res.id, \"\\\"\"));\n    }\n\n    delete idMap[res.id]; // copy whole res onto original res\n\n    Object.assign(context.res, res); // run callback on empty stack,\n    // prevent internal stream-handler from catching errors\n\n    setTimeout(context.end);\n  }\n\n  function processNotification(res) {\n    events.emit(\"notification\", res);\n  }\n\n  function processMessage(res, _encoding, cb) {\n    let err;\n\n    try {\n      const isNotification = !res.id;\n\n      if (isNotification) {\n        processNotification(res);\n      } else {\n        processResponse(res);\n      }\n    } catch (_err) {\n      err = _err;\n    } // continue processing stream\n\n\n    cb(err);\n  }\n\n  const stream = new Duplex({\n    objectMode: true,\n    read: readNoop,\n    write: processMessage\n  });\n\n  const middleware = (req, res, next, end) => {\n    // write req to stream\n    stream.push(req); // register request on id map\n\n    idMap[req.id] = {\n      req,\n      res,\n      next,\n      end\n    };\n  };\n\n  return {\n    events,\n    middleware,\n    stream\n  };\n}\nfunction createScaffoldMiddleware(handlers) {\n  return (req, res, next, end) => {\n    const handler = handlers[req.method]; // if no handler, return\n\n    if (handler === undefined) {\n      return next();\n    } // if handler is fn, call as middleware\n\n\n    if (typeof handler === \"function\") {\n      return handler(req, res, next, end);\n    } // if handler is some other value, use as result\n\n\n    res.result = handler;\n    return end();\n  };\n}\nfunction createIdRemapMiddleware() {\n  return (req, res, next, _end) => {\n    const originalId = req.id;\n    const newId = randomId();\n    req.id = newId;\n    res.id = newId;\n    next(done => {\n      req.id = originalId;\n      res.id = originalId;\n      done();\n    });\n  };\n}\nfunction createLoggerMiddleware(logger) {\n  return (req, res, next, _) => {\n    logger.debug(\"REQ\", req, \"RES\", res);\n    next();\n  };\n}\nfunction createAsyncMiddleware(asyncMiddleware) {\n  return async (req, res, next, end) => {\n    // nextPromise is the key to the implementation\n    // it is resolved by the return handler passed to the\n    // \"next\" function\n    let resolveNextPromise;\n    const nextPromise = new Promise(resolve => {\n      resolveNextPromise = resolve;\n    });\n    let returnHandlerCallback = null;\n    let nextWasCalled = false; // This will be called by the consumer's async middleware.\n\n    const asyncNext = async () => {\n      nextWasCalled = true; // We pass a return handler to next(). When it is called by the engine,\n      // the consumer's async middleware will resume executing.\n\n      next(runReturnHandlersCallback => {\n        // This callback comes from JRPCEngine._runReturnHandlers\n        returnHandlerCallback = runReturnHandlersCallback;\n        resolveNextPromise();\n      });\n      await nextPromise;\n    };\n\n    try {\n      await asyncMiddleware(req, res, asyncNext);\n\n      if (nextWasCalled) {\n        await nextPromise; // we must wait until the return handler is called\n\n        returnHandlerCallback(null);\n      } else {\n        end(null);\n      }\n    } catch (error) {\n      if (returnHandlerCallback) {\n        returnHandlerCallback(error);\n      } else {\n        end(error);\n      }\n    }\n  };\n}\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n/**\n * A JSON-RPC request and response processor.\n * Give it a stack of middleware, pass it requests, and get back responses.\n */\n\nclass JRPCEngine extends SafeEventEmitter {\n  constructor() {\n    super();\n\n    _defineProperty(this, \"_middleware\", void 0);\n\n    this._middleware = [];\n  }\n  /**\n   * Serially executes the given stack of middleware.\n   *\n   * @returns An array of any error encountered during middleware execution,\n   * a boolean indicating whether the request was completed, and an array of\n   * middleware-defined return handlers.\n   */\n\n\n  static async _runAllMiddleware(req, res, middlewareStack) {\n    const returnHandlers = [];\n    let error = null;\n    let isComplete = false; // Go down stack of middleware, call and collect optional returnHandlers\n\n    for (const middleware of middlewareStack) {\n      [error, isComplete] = await JRPCEngine._runMiddleware(req, res, middleware, returnHandlers);\n\n      if (isComplete) {\n        break;\n      }\n    }\n\n    return [error, isComplete, returnHandlers.reverse()];\n  }\n  /**\n   * Runs an individual middleware.\n   *\n   * @returns An array of any error encountered during middleware exection,\n   * and a boolean indicating whether the request should end.\n   */\n\n\n  static _runMiddleware(req, res, middleware, returnHandlers) {\n    return new Promise(resolve => {\n      const end = err => {\n        const error = err || res.error;\n\n        if (error) {\n          res.error = serializeError(error);\n        } // True indicates that the request should end\n\n\n        resolve([error, true]);\n      };\n\n      const next = returnHandler => {\n        if (res.error) {\n          end(res.error);\n        } else {\n          if (returnHandler) {\n            if (typeof returnHandler !== \"function\") {\n              end(new SerializableError({\n                code: -32603,\n                message: \"JRPCEngine: 'next' return handlers must be functions\"\n              }));\n            }\n\n            returnHandlers.push(returnHandler);\n          } // False indicates that the request should not end\n\n\n          resolve([null, false]);\n        }\n      };\n\n      try {\n        middleware(req, res, next, end);\n      } catch (error) {\n        end(error);\n      }\n    });\n  }\n  /**\n   * Serially executes array of return handlers. The request and response are\n   * assumed to be in their scope.\n   */\n\n\n  static async _runReturnHandlers(handlers) {\n    for (const handler of handlers) {\n      await new Promise((resolve, reject) => {\n        handler(err => err ? reject(err) : resolve());\n      });\n    }\n  }\n  /**\n   * Throws an error if the response has neither a result nor an error, or if\n   * the \"isComplete\" flag is falsy.\n   */\n\n\n  static _checkForCompletion(req, res, isComplete) {\n    if (!(\"result\" in res) && !(\"error\" in res)) {\n      throw new SerializableError({\n        code: -32603,\n        message: \"Response has no error or result for request\"\n      });\n    }\n\n    if (!isComplete) {\n      throw new SerializableError({\n        code: -32603,\n        message: \"Nothing ended request\"\n      });\n    }\n  }\n  /**\n   * Add a middleware function to the engine's middleware stack.\n   *\n   * @param middleware - The middleware function to add.\n   */\n\n\n  push(middleware) {\n    this._middleware.push(middleware);\n  }\n\n  handle(req, cb) {\n    if (cb && typeof cb !== \"function\") {\n      throw new Error('\"callback\" must be a function if provided.');\n    }\n\n    if (Array.isArray(req)) {\n      if (cb) {\n        return this._handleBatch(req, cb);\n      }\n\n      return this._handleBatch(req);\n    }\n\n    if (cb) {\n      return this._handle(req, cb);\n    }\n\n    return this._promiseHandle(req);\n  }\n  /**\n   * Returns this engine as a middleware function that can be pushed to other\n   * engines.\n   *\n   * @returns This engine as a middleware function.\n   */\n\n\n  asMiddleware() {\n    return async (req, res, next, end) => {\n      try {\n        const [middlewareError, isComplete, returnHandlers] = await JRPCEngine._runAllMiddleware(req, res, this._middleware);\n\n        if (isComplete) {\n          await JRPCEngine._runReturnHandlers(returnHandlers);\n          return end(middlewareError);\n        }\n\n        return next(async handlerCallback => {\n          try {\n            await JRPCEngine._runReturnHandlers(returnHandlers);\n          } catch (error) {\n            return handlerCallback(error);\n          }\n\n          return handlerCallback();\n        });\n      } catch (error) {\n        return end(error);\n      }\n    };\n  }\n\n  async _handleBatch(reqs, cb) {\n    // The order here is important\n    try {\n      // 2. Wait for all requests to finish, or throw on some kind of fatal\n      // error\n      const responses = await Promise.all( // 1. Begin executing each request in the order received\n      reqs.map(this._promiseHandle.bind(this))); // 3. Return batch response\n\n      if (cb) {\n        return cb(null, responses);\n      }\n\n      return responses;\n    } catch (error) {\n      if (cb) {\n        return cb(error);\n      }\n\n      throw error;\n    }\n  }\n  /**\n   * A promise-wrapped _handle.\n   */\n\n\n  _promiseHandle(req) {\n    return new Promise(resolve => {\n      this._handle(req, (_err, res) => {\n        // There will always be a response, and it will always have any error\n        // that is caught and propagated.\n        resolve(res);\n      });\n    });\n  }\n  /**\n   * Ensures that the request object is valid, processes it, and passes any\n   * error and the response object to the given callback.\n   *\n   * Does not reject.\n   */\n\n\n  async _handle(callerReq, cb) {\n    if (!callerReq || Array.isArray(callerReq) || typeof callerReq !== \"object\") {\n      const error = new SerializableError({\n        code: -32603,\n        message: \"request must be plain object\"\n      });\n      return cb(error, {\n        id: undefined,\n        jsonrpc: \"2.0\",\n        error\n      });\n    }\n\n    if (typeof callerReq.method !== \"string\") {\n      const error = new SerializableError({\n        code: -32603,\n        message: \"method must be string\"\n      });\n      return cb(error, {\n        id: callerReq.id,\n        jsonrpc: \"2.0\",\n        error\n      });\n    }\n\n    const req = _objectSpread$1({}, callerReq);\n\n    const res = {\n      id: req.id,\n      jsonrpc: req.jsonrpc\n    };\n    let error = null;\n\n    try {\n      await this._processRequest(req, res);\n    } catch (_error) {\n      // A request handler error, a re-thrown middleware error, or something\n      // unexpected.\n      error = _error;\n    }\n\n    if (error) {\n      // Ensure no result is present on an errored response\n      delete res.result;\n\n      if (!res.error) {\n        res.error = serializeError(error);\n      }\n    }\n\n    return cb(error, res);\n  }\n  /**\n   * For the given request and response, runs all middleware and their return\n   * handlers, if any, and ensures that internal request processing semantics\n   * are satisfied.\n   */\n\n\n  async _processRequest(req, res) {\n    const [error, isComplete, returnHandlers] = await JRPCEngine._runAllMiddleware(req, res, this._middleware); // Throw if \"end\" was not called, or if the response has neither a result\n    // nor an error.\n\n    JRPCEngine._checkForCompletion(req, res, isComplete); // The return handlers should run even if an error was encountered during\n    // middleware processing.\n\n\n    await JRPCEngine._runReturnHandlers(returnHandlers); // Now we re-throw the middleware processing error, if any, to catch it\n    // further up the call chain.\n\n    if (error) {\n      throw error;\n    }\n  }\n\n}\nfunction mergeMiddleware(middlewareStack) {\n  const engine = new JRPCEngine();\n  middlewareStack.forEach(middleware => engine.push(middleware));\n  return engine.asMiddleware();\n}\nfunction createEngineStream(opts) {\n  if (!opts || !opts.engine) {\n    throw new Error(\"Missing engine parameter!\");\n  }\n\n  const {\n    engine\n  } = opts; // eslint-disable-next-line prefer-const\n\n  let stream;\n\n  function read() {\n    return undefined;\n  }\n\n  function write(req, _encoding, cb) {\n    engine.handle(req, (_err, res) => {\n      stream.push(res);\n    });\n    cb();\n  }\n\n  stream = new Duplex({\n    objectMode: true,\n    read,\n    write\n  }); // forward notifications\n\n  if (engine.on) {\n    engine.on(\"notification\", message => {\n      stream.push(message);\n    });\n  }\n\n  return stream;\n}\n\nclass Substream extends Duplex {\n  constructor(_ref) {\n    let {\n      parent,\n      name\n    } = _ref;\n    super({\n      objectMode: true\n    });\n\n    _defineProperty(this, \"_parent\", void 0);\n\n    _defineProperty(this, \"_name\", void 0);\n\n    this._parent = parent;\n    this._name = name;\n  }\n  /**\n   * Explicitly sets read operations to a no-op.\n   */\n\n\n  _read() {\n    return undefined;\n  }\n  /**\n   * Called when data should be written to this writable stream.\n   *\n   * @param chunk - Arbitrary object to write\n   * @param encoding - Encoding to use when writing payload\n   * @param callback - Called when writing is complete or an error occurs\n   */\n\n\n  _write(chunk, _encoding, callback) {\n    this._parent.push({\n      name: this._name,\n      data: chunk\n    });\n\n    callback();\n  }\n\n}\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nconst IGNORE_SUBSTREAM = Symbol(\"IGNORE_SUBSTREAM\");\nclass ObjectMultiplex extends Duplex {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(_objectSpread(_objectSpread({}, opts), {}, {\n      objectMode: true\n    }));\n\n    _defineProperty(this, \"_substreams\", void 0);\n\n    _defineProperty(this, \"getStream\", void 0);\n\n    this._substreams = {};\n  }\n\n  createStream(name) {\n    // validate name\n    if (!name) {\n      throw new Error(\"ObjectMultiplex - name must not be empty\");\n    }\n\n    if (this._substreams[name]) {\n      throw new Error(\"ObjectMultiplex - Substream for name \\\"\".concat(name, \"\\\" already exists\"));\n    } // create substream\n\n\n    const substream = new Substream({\n      parent: this,\n      name\n    });\n    this._substreams[name] = substream; // listen for parent stream to end\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n    anyStreamEnd(this, _error => substream.destroy(_error || undefined));\n    return substream;\n  } // ignore streams (dont display orphaned data warning)\n\n\n  ignoreStream(name) {\n    // validate name\n    if (!name) {\n      throw new Error(\"ObjectMultiplex - name must not be empty\");\n    }\n\n    if (this._substreams[name]) {\n      throw new Error(\"ObjectMultiplex - Substream for name \\\"\".concat(name, \"\\\" already exists\"));\n    } // set\n\n\n    this._substreams[name] = IGNORE_SUBSTREAM;\n  }\n\n  _read() {\n    return undefined;\n  }\n\n  _write(chunk, _encoding, callback) {\n    const {\n      name,\n      data\n    } = chunk;\n\n    if (!name) {\n      window.console.warn(\"ObjectMultiplex - malformed chunk without name \\\"\".concat(chunk, \"\\\"\"));\n      return callback();\n    } // get corresponding substream\n\n\n    const substream = this._substreams[name];\n\n    if (!substream) {\n      window.console.warn(\"ObjectMultiplex - orphaned data for stream \\\"\".concat(name, \"\\\"\"));\n      return callback();\n    } // push data into substream\n\n\n    if (substream !== IGNORE_SUBSTREAM) {\n      substream.push(data);\n    }\n\n    return callback();\n  }\n\n} // util\n\nfunction anyStreamEnd(stream, _cb) {\n  const cb = once(_cb);\n  eos(stream, {\n    readable: false\n  }, cb);\n  eos(stream, {\n    writable: false\n  }, cb);\n}\n\nfunction setupMultiplex(stream) {\n  const mux = new ObjectMultiplex();\n\n  mux.getStream = function streamHelper(name) {\n    if (this._substreams[name]) {\n      return this._substreams[name];\n    }\n\n    return this.createStream(name);\n  };\n\n  pump(stream, mux, stream, err => {\n    if (err) window.console.error(err);\n  });\n  return mux;\n}\n\nclass PostMessageStream extends BasePostMessageStream {\n  _postMessage(data) {\n    let originConstraint = this._targetOrigin;\n\n    if (typeof data === \"object\") {\n      const dataObj = data;\n\n      if (typeof dataObj.data === \"object\") {\n        const dataObjData = dataObj.data;\n\n        if (Array.isArray(dataObjData.params) && dataObjData.params.length > 0) {\n          const dataObjDataParam = dataObjData.params[0];\n\n          if (dataObjDataParam._origin) {\n            originConstraint = dataObjDataParam._origin;\n          } // add a constraint for the response\n\n\n          dataObjDataParam._origin = window.location.origin;\n        }\n      }\n    }\n\n    this._targetWindow.postMessage({\n      target: this._target,\n      data\n    }, originConstraint);\n  }\n\n}\n\nexport { BasePostMessageStream, IGNORE_SUBSTREAM, JRPCEngine, ObjectMultiplex, PostMessageStream, SafeEventEmitter, SerializableError, Substream, createAsyncMiddleware, createEngineStream, createErrorMiddleware, createIdRemapMiddleware, createLoggerMiddleware, createScaffoldMiddleware, createStreamMiddleware, getRpcPromiseCallback, mergeMiddleware, setupMultiplex };\n//# sourceMappingURL=openloginJrpc.esm.js.map\n",null,null,null,null,null,null,"exports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\nexports.finished = require('./lib/internal/streams/end-of-stream.js');\nexports.pipeline = require('./lib/internal/streams/pipeline.js');\n","'use strict';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar _require2 = require('util'),\n    inspect = _require2.inspect;\n\nvar custom = inspect && inspect.custom || 'inspect';\n\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  _createClass(BufferList, [{\n    key: \"push\",\n    value: function push(v) {\n      var entry = {\n        data: v,\n        next: null\n      };\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n      this.tail = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(v) {\n      var entry = {\n        data: v,\n        next: this.head\n      };\n      if (this.length === 0) this.tail = entry;\n      this.head = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.length === 0) return;\n      var ret = this.head.data;\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n      --this.length;\n      return ret;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n  }, {\n    key: \"join\",\n    value: function join(s) {\n      if (this.length === 0) return '';\n      var p = this.head;\n      var ret = '' + p.data;\n\n      while (p = p.next) {\n        ret += s + p.data;\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(n) {\n      if (this.length === 0) return Buffer.alloc(0);\n      var ret = Buffer.allocUnsafe(n >>> 0);\n      var p = this.head;\n      var i = 0;\n\n      while (p) {\n        copyBuffer(p.data, ret, i);\n        i += p.data.length;\n        p = p.next;\n      }\n\n      return ret;\n    } // Consumes a specified amount of bytes or characters from the buffered data.\n\n  }, {\n    key: \"consume\",\n    value: function consume(n, hasStrings) {\n      var ret;\n\n      if (n < this.head.data.length) {\n        // `slice` is the same for buffers and strings.\n        ret = this.head.data.slice(0, n);\n        this.head.data = this.head.data.slice(n);\n      } else if (n === this.head.data.length) {\n        // First chunk is a perfect match.\n        ret = this.shift();\n      } else {\n        // Result spans more than one buffer.\n        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.head.data;\n    } // Consumes a specified amount of characters from the buffered data.\n\n  }, {\n    key: \"_getString\",\n    value: function _getString(n) {\n      var p = this.head;\n      var c = 1;\n      var ret = p.data;\n      n -= ret.length;\n\n      while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === str.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = str.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Consumes a specified amount of bytes from the buffered data.\n\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer(n) {\n      var ret = Buffer.allocUnsafe(n);\n      var p = this.head;\n      var c = 1;\n      p.data.copy(ret);\n      n -= p.data.length;\n\n      while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === buf.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = buf.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Make sure the linked list only shows the minimal necessary information.\n\n  }, {\n    key: custom,\n    value: function value(_, options) {\n      return inspect(this, _objectSpread({}, options, {\n        // Only inspect one level.\n        depth: 0,\n        // It should not recurse.\n        customInspect: false\n      }));\n    }\n  }]);\n\n  return BufferList;\n}();","'use strict';\n\nvar _Object$setPrototypeO;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar finished = require('./end-of-stream');\n\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\n\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\n\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n\n  if (resolve !== null) {\n    var data = iter[kStream].read(); // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\n\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\n\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\n\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n\n  next: function next() {\n    var _this = this;\n\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    } // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n\n\n    var lastPromise = this[kLastPromise];\n    var promise;\n\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n\n      promise = new Promise(this[kHandlePromise]);\n    }\n\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\n\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n\n      iterator[kError] = err;\n      return;\n    }\n\n    var resolve = iterator[kLastResolve];\n\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\n\nmodule.exports = createReadableStreamAsyncIterator;","module.exports = function () {\n  throw new Error('Readable.from is not available in the browser')\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\nrequire('inherits')(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n'use strict';\n\nvar eos;\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    callback.apply(void 0, arguments);\n  };\n}\n\nvar _require$codes = require('../../../errors').codes,\n    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\n\nfunction noop(err) {\n  // Rethrow the error if it exists to avoid swallowing it\n  if (err) throw err;\n}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction destroyer(stream, reading, writing, callback) {\n  callback = once(callback);\n  var closed = false;\n  stream.on('close', function () {\n    closed = true;\n  });\n  if (eos === undefined) eos = require('./end-of-stream');\n  eos(stream, {\n    readable: reading,\n    writable: writing\n  }, function (err) {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  var destroyed = false;\n  return function (err) {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true; // request.destroy just do .end - .abort is what we want\n\n    if (isRequest(stream)) return stream.abort();\n    if (typeof stream.destroy === 'function') return stream.destroy();\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\n  };\n}\n\nfunction call(fn) {\n  fn();\n}\n\nfunction pipe(from, to) {\n  return from.pipe(to);\n}\n\nfunction popCallback(streams) {\n  if (!streams.length) return noop;\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\n  return streams.pop();\n}\n\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n\n  var callback = popCallback(streams);\n  if (Array.isArray(streams[0])) streams = streams[0];\n\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n\n  var error;\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1;\n    var writing = i > 0;\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach(call);\n      if (reading) return;\n      destroys.forEach(call);\n      callback(error);\n    });\n  });\n  return streams.reduce(pipe);\n}\n\nmodule.exports = pipeline;","import randombytes from 'randombytes';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport base64urlLib from 'base64url';\nimport keccakLib from 'keccak';\n\n// TODO: should be crypto safe\nconst randomId = () => randombytes(32).toString(\"hex\");\n\nclass URLWithHashParams extends URL {\n  constructor() {\n    super(...arguments);\n\n    _defineProperty(this, \"hashParams\", new URLSearchParams());\n  }\n\n  toString() {\n    this.hash = this.hashParams.toString();\n    return super.toString.call(this);\n  }\n\n}\n\nconst base64url = base64urlLib;\nfunction safebtoa(str) {\n  return base64url.encode(str);\n}\nfunction safeatob(str) {\n  // Going backwards: from bytestream, to percent-encoding, to original string.\n  return base64url.decode(str);\n}\nconst keccak = keccakLib;\nfunction base64toJSON(b64str) {\n  return JSON.parse(base64url.decode(b64str));\n}\nfunction jsonToBase64(json) {\n  return base64url.encode(JSON.stringify(json));\n}\nfunction keccak256(str) {\n  let input = str;\n\n  if (typeof str === \"string\" && str.slice(0, 2) === \"0x\" && str.length === 66) {\n    input = Buffer.from(str.slice(2), \"hex\");\n  }\n\n  const data = \"0x\".concat(keccak(\"keccak256\").update(input).digest(\"hex\").padStart(64, \"0\"));\n  return data;\n}\n\nexport { URLWithHashParams, base64toJSON, base64url, jsonToBase64, keccak, keccak256, randomId, safeatob, safebtoa };\n//# sourceMappingURL=openloginUtils.esm.js.map\n",null,"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport Torus from '@toruslabs/solana-embed';\nimport { BaseAdapter, WALLET_ADAPTERS, ADAPTER_NAMESPACES, CHAIN_NAMESPACES, ADAPTER_CATEGORY, ADAPTER_STATUS, getChainConfig, log, ADAPTER_EVENTS, WalletInitializationError, Web3AuthError, WalletLoginError } from '@web3auth/base';\nimport { TorusInjectedProvider } from '@web3auth/solana-provider';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass SolanaWalletAdapter extends BaseAdapter {\n  constructor() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.TORUS_SOLANA);\n\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.SOLANA);\n\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.SOLANA);\n\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.EXTERNAL);\n\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(this, \"torusInstance\", null);\n\n    _defineProperty(this, \"torusWalletOptions\", void 0);\n\n    _defineProperty(this, \"initParams\", void 0);\n\n    _defineProperty(this, \"loginSettings\", {});\n\n    _defineProperty(this, \"solanaProvider\", null);\n\n    _defineProperty(this, \"rehydrated\", false);\n\n    this.torusWalletOptions = params.adapterSettings || {};\n    this.initParams = params.initParams || {};\n    this.loginSettings = params.loginSettings || {};\n    this.chainConfig = params.chainConfig || null;\n  }\n\n  get provider() {\n    if (this.status === ADAPTER_STATUS.CONNECTED && this.solanaProvider) {\n      var _this$solanaProvider;\n\n      return ((_this$solanaProvider = this.solanaProvider) === null || _this$solanaProvider === void 0 ? void 0 : _this$solanaProvider.provider) || null;\n    }\n\n    return null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init(options) {\n    super.checkInitializationRequirements(); // set chainConfig for mainnet by default if not set\n\n    let network;\n\n    if (!this.chainConfig) {\n      this.chainConfig = getChainConfig(CHAIN_NAMESPACES.SOLANA, \"0x1\");\n      const {\n        blockExplorer,\n        displayName,\n        ticker,\n        tickerName,\n        rpcTarget,\n        chainId\n      } = this.chainConfig;\n      network = {\n        chainId,\n        rpcTarget,\n        blockExplorerUrl: blockExplorer,\n        displayName,\n        ticker,\n        tickerName,\n        logo: \"\"\n      };\n    } else {\n      const {\n        chainId,\n        blockExplorer,\n        displayName,\n        rpcTarget,\n        ticker,\n        tickerName\n      } = this.chainConfig;\n      network = {\n        chainId,\n        rpcTarget,\n        blockExplorerUrl: blockExplorer,\n        displayName,\n        tickerName,\n        ticker,\n        logo: \"\"\n      };\n    }\n\n    this.torusInstance = new Torus(this.torusWalletOptions);\n    log.debug(\"initializing torus solana adapter init\");\n    await this.torusInstance.init(_objectSpread(_objectSpread({\n      showTorusButton: false\n    }, this.initParams), {}, {\n      network\n    }));\n    this.solanaProvider = new TorusInjectedProvider({\n      config: {\n        chainConfig: this.chainConfig\n      }\n    });\n    this.status = ADAPTER_STATUS.READY;\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.TORUS_SOLANA);\n\n    try {\n      log.debug(\"initializing torus solana adapter\");\n\n      if (options.autoConnect) {\n        this.rehydrated = true;\n        await this.connect();\n      }\n    } catch (error) {\n      log.error(\"Failed to connect with cached torus solana provider\", error);\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n    }\n  }\n\n  async connect() {\n    super.checkConnectionRequirements();\n    if (!this.torusInstance) throw WalletInitializationError.notReady(\"Torus wallet is not initialized\");\n    if (!this.solanaProvider) throw WalletInitializationError.notReady(\"Torus wallet is not initialized\");\n    this.status = ADAPTER_STATUS.CONNECTING;\n    this.emit(ADAPTER_EVENTS.CONNECTING, {\n      adapter: WALLET_ADAPTERS.TORUS_SOLANA\n    });\n\n    try {\n      await this.torusInstance.login(this.loginSettings);\n\n      try {\n        const torusInpageProvider = this.torusInstance.provider;\n        torusInpageProvider.sendTransaction = this.torusInstance.sendTransaction.bind(this.torusInstance);\n        torusInpageProvider.signAllTransactions = this.torusInstance.signAllTransactions.bind(this.torusInstance);\n        torusInpageProvider.signMessage = this.torusInstance.signMessage.bind(this.torusInstance);\n        torusInpageProvider.signTransaction = this.torusInstance.signTransaction.bind(this.torusInstance);\n        await this.solanaProvider.setupProvider(torusInpageProvider);\n      } catch (error) {\n        // some issue in solana wallet, always connecting to mainnet on init.\n        // fallback to change network if not connected to correct one on login.\n        if (error instanceof Web3AuthError && error.code === 5010) {\n          const {\n            chainId,\n            blockExplorer,\n            displayName,\n            rpcTarget,\n            ticker,\n            tickerName\n          } = this.chainConfig;\n          const network = {\n            chainId,\n            rpcTarget,\n            blockExplorerUrl: blockExplorer,\n            displayName,\n            tickerName,\n            ticker,\n            logo: \"\"\n          };\n          await this.torusInstance.setProvider(network);\n        } else {\n          throw error;\n        }\n      }\n\n      this.status = ADAPTER_STATUS.CONNECTED;\n      this.torusInstance.showTorusButton();\n      this.emit(ADAPTER_STATUS.CONNECTED, {\n        adapter: WALLET_ADAPTERS.TORUS_SOLANA,\n        reconnected: this.rehydrated\n      });\n      return this.provider;\n    } catch (error) {\n      // ready again to be connected\n      this.status = ADAPTER_STATUS.READY;\n      this.rehydrated = false;\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n      throw WalletLoginError.connectionError(\"Failed to login with torus solana wallet\");\n    }\n  }\n\n  async disconnect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.torusInstance) throw WalletInitializationError.notReady(\"Torus wallet is not initialized\");\n    await this.torusInstance.logout();\n\n    if (options.cleanup) {\n      // ready to connect again\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.torusInstance = null;\n      this.solanaProvider = null;\n    } else {\n      // ready to connect again\n      this.status = ADAPTER_STATUS.READY;\n    }\n\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n\n  async getUserInfo() {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.torusInstance) throw WalletInitializationError.notReady(\"Torus wallet is not initialized\");\n    const userInfo = await this.torusInstance.getUserInfo();\n    return userInfo;\n  }\n\n  setAdapterSettings(_) {}\n\n}\n\nexport { SolanaWalletAdapter };\n//# sourceMappingURL=torusSolanaAdapter.esm.js.map\n"],"sourceRoot":""}